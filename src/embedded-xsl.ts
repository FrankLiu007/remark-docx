// 自动生成的内嵌 XSL 内容
// 来源: MML2OMML.XSL
// 生成时间: 2025-10-06T03:34:48.351Z

export const EMBEDDED_XSL_CONTENT = `<?xml version="1.0" encoding="UTF-8" ?>\r\n<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:mml="http://www.w3.org/1998/Math/MathML"\r\n\txmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math">\r\n  <xsl:output method="xml" encoding="UTF-8" />\r\n\r\n\r\n  <xsl:variable name="StrUCAlphabet">ABCDEFGHIJKLMNOPQRSTUVWXYZ</xsl:variable>\r\n  <xsl:variable name="StrLCAlphabet">abcdefghijklmnopqrstuvwxyz</xsl:variable>\r\n\r\n  <!-- %%Template: match *\r\n\r\n\t\tThe catch all template, just passes through \r\n\t-->\r\n  <xsl:template match="*">\r\n    <xsl:apply-templates select="*" />\r\n  </xsl:template>\r\n\r\n  <!-- %%Template: match *\r\n\r\n\t\tAnother catch all template, just passes through \r\n\t-->\r\n  <xsl:template match="/">\r\n    <m:oMath>\r\n      <xsl:apply-templates select="*" />\r\n    </m:oMath>\r\n  </xsl:template>\r\n\r\n  <!-- %%Template: SReplace\r\n\r\n\t\tReplace all occurences of sOrig in sInput with sReplacement\r\n\t\tand return the resulting string. -->\r\n  <xsl:template name="SReplace">\r\n    <xsl:param name="sInput" />\r\n    <xsl:param name="sOrig" />\r\n    <xsl:param name="sReplacement" />\r\n\r\n    <xsl:choose>\r\n      <xsl:when test="not(contains($sInput, $sOrig))">\r\n        <xsl:value-of select="$sInput" />\r\n      </xsl:when>\r\n      <xsl:otherwise>\r\n        <xsl:variable name="sBefore" select="substring-before($sInput, $sOrig)" />\r\n        <xsl:variable name="sAfter" select="substring-after($sInput, $sOrig)" />\r\n        <xsl:variable name="sAfterProcessed">\r\n          <xsl:call-template name="SReplace">\r\n            <xsl:with-param name="sInput" select="$sAfter" />\r\n            <xsl:with-param name="sOrig" select="$sOrig" />\r\n            <xsl:with-param name="sReplacement" select="$sReplacement" />\r\n          </xsl:call-template>\r\n        </xsl:variable>\r\n\r\n        <xsl:value-of select="concat($sBefore, concat($sReplacement, $sAfterProcessed))" />\r\n      </xsl:otherwise>\r\n    </xsl:choose>\r\n  </xsl:template>\r\n\r\n  <!-- %%Template: OutputText\r\n\r\n\t\tPost processing on the string given and otherwise do\r\n\t\ta xsl:value-of on it -->\r\n  <xsl:template name="OutputText">\r\n    <xsl:param name="sInput" />\r\n\r\n    <!-- Add local variable as you add new post processing tasks -->\r\n\r\n    <!-- 1. Remove any unwanted characters -->\r\n    <xsl:variable name="sCharStrip">\r\n      <xsl:value-of select="translate($sInput, '&#x2062;&#x200B;', '')" />\r\n    </xsl:variable>\r\n\r\n    <!-- 2. Replace any characters as needed -->\r\n    <!--\tReplace &#x2A75; <-> ==\t\t\t -->\r\n    <xsl:variable name="sCharReplace">\r\n      <xsl:call-template name="SReplace">\r\n        <xsl:with-param name="sInput" select="$sCharStrip" />\r\n        <xsl:with-param name="sOrig" select="'&#x2A75;'" />\r\n        <xsl:with-param name="sReplacement" select="'=='" />\r\n      </xsl:call-template>\r\n    </xsl:variable>\r\n\r\n    <!-- Replace &#xa0; (non-breaking space) with ' ' -->\r\n    <xsl:variable name="sCharReplaceFinal" select="translate($sCharReplace, '&#xa0;', ' ')" />\r\n\r\n    <!-- Finally, return the last value -->\r\n    <xsl:value-of select="$sCharReplaceFinal" />\r\n  </xsl:template>\r\n\r\n\r\n  <!-- Template that determines whether or the given node \r\n\t     ndCur is a token element that doesn't have an mglyph as \r\n\t\t\t a child.\r\n\t-->\r\n  <xsl:template name="FNonGlyphToken">\r\n    <xsl:param name="ndCur" select="." />\r\n    <xsl:choose>\r\n      <xsl:when test="$ndCur/self::mml:mi[not(child::mml:mglyph)] | \r\n\t                     $ndCur/self::mml:mn[not(child::mml:mglyph)] | \r\n\t                     $ndCur/self::mml:mo[not(child::mml:mglyph)] | \r\n\t                     $ndCur/self::mml:ms[not(child::mml:mglyph)] |\r\n                       $ndCur/self::mml:mtext[not(child::mml:mglyph)]">1</xsl:when>\r\n      <xsl:otherwise>0</xsl:otherwise>\r\n    </xsl:choose>\r\n  </xsl:template>\r\n\r\n\r\n  <!-- Template used to determine if the current token element (ndCur) is the beginning of a run. \r\n\t\t\t A token element is the beginning of if:\r\n\t\t\t \r\n\t\t\t the count of preceding elements is 0 \r\n\t\t\t or \r\n\t\t\t the directory preceding element is not a non-glyph token.\r\n\t-->\r\n  <xsl:template name="FStartOfRun">\r\n    <xsl:param name="ndCur" select="." />\r\n    <xsl:variable name="fPrecSibNonGlyphToken">\r\n      <xsl:call-template name="FNonGlyphToken">\r\n        <xsl:with-param name="ndCur" select="$ndCur/preceding-sibling::*[1]" />\r\n      </xsl:call-template>\r\n    </xsl:variable>\r\n    <xsl:choose>\r\n      <xsl:when test="count($ndCur/preceding-sibling::*)=0 \r\n\t\t\t\t\t\t\t\t\t\t\tor $fPrecSibNonGlyphToken=0">1</xsl:when>\r\n      <xsl:otherwise>0</xsl:otherwise>\r\n    </xsl:choose>\r\n  </xsl:template>\r\n\r\n  <!-- Template that determines if ndCur is the argument of an nary expression. \r\n\t\t\t \r\n\t\t\t ndCur is the argument of an nary expression if:\r\n\t\t\t \r\n\t\t\t 1.  The preceding sibling is one of the following:  munder, mover, msub, msup, munder, msubsup, munderover\r\n\t\t\t and\r\n\t\t\t 2.  The preceding sibling's child is an nary char as specified by the template "isNary"\r\n\t-->\r\n  <xsl:template name="FIsNaryArgument">\r\n    <xsl:param name="ndCur" select="." />\r\n\r\n    <xsl:variable name="fNary">\r\n      <xsl:call-template name="isNary">\r\n        <xsl:with-param name="ndCur" select="$ndCur/preceding-sibling::*[1]/child::*[1]" />\r\n      </xsl:call-template>\r\n    </xsl:variable>\r\n    <xsl:choose>\r\n      <xsl:when test="preceding-sibling::*[1][self::mml:munder or self::mml:mover or self::mml:munderover or\r\n                                                    self::mml:msub or self::mml:msup or self::mml:msubsup]\r\n\t\t\t\t\t\t\t      and $fNary='true'">1</xsl:when>\r\n      <xsl:otherwise>0</xsl:otherwise>\r\n    </xsl:choose>\r\n  </xsl:template>\r\n\r\n  <!-- %%Template: mml:mrow | mml:mstyle\r\n\r\n\t\t if this row is the next sibling of an n-ary (i.e. any of \r\n         mover, munder, munderover, msupsub, msup, or msub with \r\n         the base being an n-ary operator) then ignore this. Otherwise\r\n         pass through -->\r\n  <xsl:template match="mml:mrow|mml:mstyle">\r\n    <xsl:variable name="fNaryArgument">\r\n      <xsl:call-template name="FIsNaryArgument">\r\n        <xsl:with-param name="ndCur" select="."/>\r\n      </xsl:call-template>\r\n    </xsl:variable>\r\n    <xsl:if test="$fNaryArgument=0">\r\n      <xsl:variable name="fLinearFrac">\r\n        <xsl:call-template name="FLinearFrac">\r\n          <xsl:with-param name="ndCur" select="." />\r\n        </xsl:call-template>\r\n      </xsl:variable>\r\n      <xsl:choose>\r\n        <xsl:when test="$fLinearFrac=1">\r\n          <xsl:call-template name="MakeLinearFraction">\r\n            <xsl:with-param name="ndCur" select="." />\r\n          </xsl:call-template>\r\n        </xsl:when>\r\n        <xsl:otherwise>\r\n          <xsl:variable name="fFunc">\r\n            <xsl:call-template name="FIsFunc">\r\n              <xsl:with-param name="ndCur" select="." />\r\n            </xsl:call-template>\r\n          </xsl:variable>\r\n          <xsl:choose>\r\n            <xsl:when test="$fFunc=1">\r\n              <xsl:call-template name="WriteFunc">\r\n                <xsl:with-param name="ndCur" select="." />\r\n              </xsl:call-template>\r\n            </xsl:when>\r\n            <xsl:otherwise>\r\n              <xsl:apply-templates select="*" />\r\n            </xsl:otherwise>\r\n          </xsl:choose>\r\n        </xsl:otherwise>\r\n      </xsl:choose>\r\n    </xsl:if>\r\n  </xsl:template>\r\n  <xsl:template match="mml:mi[not(child::mml:mglyph)] | \r\n\t                     mml:mn[not(child::mml:mglyph)] | \r\n\t                     mml:mo[not(child::mml:mglyph)] | \r\n\t                     mml:ms[not(child::mml:mglyph)] |\r\n                       mml:mtext[not(child::mml:mglyph)]">\r\n\r\n    <!-- tokens with mglyphs as children are tranformed\r\n\t\t\t in a different manner than "normal" token elements.  \r\n\t\t\t Where normal token elements are token elements that\r\n\t\t\t contain only text -->\r\n    <xsl:variable name="fStartOfRun">\r\n      <xsl:call-template name="FStartOfRun">\r\n        <xsl:with-param name="ndCur" select="." />\r\n      </xsl:call-template>\r\n    </xsl:variable>\r\n\r\n    <!--In MathML, successive characters that are all part of one string are sometimes listed as separate \r\n\t\t\ttags based on their type (identifier (mi), name (mn), operator (mo), quoted (ms), literal text (mtext)), \r\n\t\t\twhere said tags act to link one another into one logical run.  In order to wrap the text of successive mi's, \r\n\t\t\tmn's, and mo's into one m:t, we need to denote where a run begins.  The beginning of a run is the first mi, mn, \r\n\t\t\tor mo whose immediately preceding sibling either doesn't exist or is something other than a "normal" mi, mn, mo, \r\n\t\t\tms, or mtext tag-->\r\n\r\n    <!-- If this mi/mo/mn/ms . . . is part the numerator or denominator of a linear fraction, then don't collect. -->\r\n    <xsl:variable name="fLinearFracParent">\r\n      <xsl:call-template name="FLinearFrac">\r\n        <xsl:with-param name="ndCur" select="parent::*" />\r\n      </xsl:call-template>\r\n    </xsl:variable>\r\n    <!-- If this mi/mo/mn/ms . . . is part of the name of a function, then don't collect. -->\r\n    <xsl:variable name="fFunctionName">\r\n      <xsl:call-template name="FIsFunc">\r\n        <xsl:with-param name="ndCur" select="parent::*" />\r\n      </xsl:call-template>\r\n    </xsl:variable>\r\n    <xsl:variable name="fShouldCollect"\r\n\t\t\t\t\tselect="($fLinearFracParent=0 and $fFunctionName=0) and (parent::mml:mrow or parent::mml:mstyle or \r\n\t\t\t\t\tparent::mml:msqrt or parent::mml:menclose or\r\n\t\t\t\t\tparent::mml:math or parent::mml:mphantom or \r\n\t\t\t\t\tparent::mml:mtd or parent::mml:maction)" />\r\n\r\n    <!--In MathML, the meaning of the different parts that make up mathematical structures, such as a fraction \r\n\t\t\thaving a numerator and a denominator, is determined by the relative order of those different parts.  \r\n\t\t\tFor instance, In a fraction, the numerator is the first child and the denominator is the second child.  \r\n\t\t\tTo allow for more complex structures, MathML allows one to link a group of mi, mn, and mo's together \r\n\t\t\tusing the mrow, or mstyle tags.  The mi, mn, and mo's found within any of the above tags are considered \r\n\t\t\tone run.  Therefore, if the parent of any mi, mn, or mo is found to be an mrow or mstyle, then the contiguous \r\n\t\t\tmi, mn, and mo's will be considered one run.-->\r\n    <xsl:choose>\r\n      <xsl:when test="$fShouldCollect">\r\n        <xsl:choose>\r\n          <xsl:when test="$fStartOfRun=1">\r\n            <!--If this is the beginning of the run, pass all run attributes to CreateRunWithSameProp.-->\r\n            <xsl:call-template name="CreateRunWithSameProp">\r\n              <xsl:with-param name="mathbackground">\r\n                <!-- Look for the unqualified mathml attribute mathbackground.\r\n\t\t\t\t\t\t\t\t\t\t Fall back to the qualified mathml attribute if necessary.\r\n\t\t\t\t\t\t\t\t\t\t This priority of unqualified over qualified will be \r\n\t\t\t\t\t\t\t\t\t\t followed throughout this xslt. -->\r\n                <xsl:choose>\r\n                  <xsl:when test="@mathbackground">\r\n                    <xsl:value-of select="@mathbackground"/>\r\n                  </xsl:when>\r\n                  <xsl:otherwise>\r\n                    <xsl:value-of select="@mml:mathbackground"/>\r\n                  </xsl:otherwise>\r\n                </xsl:choose>\r\n              </xsl:with-param>\r\n              <xsl:with-param name="mathcolor">\r\n                <xsl:choose>\r\n                  <xsl:when test="@mathcolor">\r\n                    <xsl:value-of select="@mathcolor"/>\r\n                  </xsl:when>\r\n                  <xsl:otherwise>\r\n                    <xsl:value-of select="@mml:mathcolor"/>\r\n                  </xsl:otherwise>\r\n                </xsl:choose>\r\n              </xsl:with-param>\r\n              <xsl:with-param name="mathvariant">\r\n                <xsl:choose>\r\n                  <xsl:when test="@mathvariant">\r\n                    <xsl:value-of select="@mathvariant"/>\r\n                  </xsl:when>\r\n                  <xsl:otherwise>\r\n                    <xsl:value-of select="@mml:mathvariant"/>\r\n                  </xsl:otherwise>\r\n                </xsl:choose>\r\n              </xsl:with-param>\r\n              <xsl:with-param name="color">\r\n                <xsl:choose>\r\n                  <xsl:when test="@color">\r\n                    <xsl:value-of select="@color"/>\r\n                  </xsl:when>\r\n                  <xsl:otherwise>\r\n                    <xsl:value-of select="@mml:color"/>\r\n                  </xsl:otherwise>\r\n                </xsl:choose>\r\n              </xsl:with-param>\r\n              <xsl:with-param name="font-family">\r\n                <xsl:choose>\r\n                  <xsl:when test="@font-family">\r\n                    <xsl:value-of select="@font-family"/>\r\n                  </xsl:when>\r\n                  <xsl:otherwise>\r\n                    <xsl:value-of select="@mml:font-family"/>\r\n                  </xsl:otherwise>\r\n                </xsl:choose>\r\n              </xsl:with-param>\r\n              <xsl:with-param name="fontsize">\r\n                <xsl:choose>\r\n                  <xsl:when test="@fontsize">\r\n                    <xsl:value-of select="@fontsize"/>\r\n                  </xsl:when>\r\n                  <xsl:otherwise>\r\n                    <xsl:value-of select="@mml:fontsize"/>\r\n                  </xsl:otherwise>\r\n                </xsl:choose>\r\n              </xsl:with-param>\r\n              <xsl:with-param name="fontstyle">\r\n                <xsl:choose>\r\n                  <xsl:when test="@fontstyle">\r\n                    <xsl:value-of select="@fontstyle"/>\r\n                  </xsl:when>\r\n                  <xsl:otherwise>\r\n                    <xsl:value-of select="@mml:fontstyle"/>\r\n                  </xsl:otherwise>\r\n                </xsl:choose>\r\n              </xsl:with-param>\r\n              <xsl:with-param name="fontweight">\r\n                <xsl:choose>\r\n                  <xsl:when test="@fontweight">\r\n                    <xsl:value-of select="@fontweight"/>\r\n                  </xsl:when>\r\n                  <xsl:otherwise>\r\n                    <xsl:value-of select="@mml:fontweight"/>\r\n                  </xsl:otherwise>\r\n                </xsl:choose>\r\n              </xsl:with-param>\r\n              <xsl:with-param name="mathsize">\r\n                <xsl:choose>\r\n                  <xsl:when test="@mathsize">\r\n                    <xsl:value-of select="@mathsize"/>\r\n                  </xsl:when>\r\n                  <xsl:otherwise>\r\n                    <xsl:value-of select="@mml:mathsize"/>\r\n                  </xsl:otherwise>\r\n                </xsl:choose>\r\n              </xsl:with-param>\r\n              <xsl:with-param name="ndTokenFirst" select="." />\r\n            </xsl:call-template>\r\n          </xsl:when>\r\n        </xsl:choose>\r\n      </xsl:when>\r\n      <xsl:otherwise>\r\n        <!--Only one element will be part of run-->\r\n        <xsl:element name="m:r">\r\n          <!--Create Run Properties based on current node's attributes-->\r\n          <xsl:call-template name="CreateRunProp">\r\n            <xsl:with-param name="mathvariant">\r\n              <xsl:choose>\r\n                <xsl:when test="@mathvariant">\r\n                  <xsl:value-of select="@mathvariant"/>\r\n                </xsl:when>\r\n                <xsl:otherwise>\r\n                  <xsl:value-of select="@mml:mathvariant"/>\r\n                </xsl:otherwise>\r\n              </xsl:choose>\r\n            </xsl:with-param>\r\n            <xsl:with-param name="fontstyle">\r\n              <xsl:choose>\r\n                <xsl:when test="@fontstyle">\r\n                  <xsl:value-of select="@fontstyle"/>\r\n                </xsl:when>\r\n                <xsl:otherwise>\r\n                  <xsl:value-of select="@mml:fontstyle"/>\r\n                </xsl:otherwise>\r\n              </xsl:choose>\r\n            </xsl:with-param>\r\n            <xsl:with-param name="fontweight">\r\n              <xsl:choose>\r\n                <xsl:when test="@fontweight">\r\n                  <xsl:value-of select="@fontweight"/>\r\n                </xsl:when>\r\n                <xsl:otherwise>\r\n                  <xsl:value-of select="@mml:fontweight"/>\r\n                </xsl:otherwise>\r\n              </xsl:choose>\r\n            </xsl:with-param>\r\n            <xsl:with-param name="mathcolor">\r\n              <xsl:choose>\r\n                <xsl:when test="@mathcolor">\r\n                  <xsl:value-of select="@mathcolor"/>\r\n                </xsl:when>\r\n                <xsl:otherwise>\r\n                  <xsl:value-of select="@mml:mathcolor"/>\r\n                </xsl:otherwise>\r\n              </xsl:choose>\r\n            </xsl:with-param>\r\n            <xsl:with-param name="mathsize">\r\n              <xsl:choose>\r\n                <xsl:when test="@mathsize">\r\n                  <xsl:value-of select="@mathsize"/>\r\n                </xsl:when>\r\n                <xsl:otherwise>\r\n                  <xsl:value-of select="@mml:mathsize"/>\r\n                </xsl:otherwise>\r\n              </xsl:choose>\r\n            </xsl:with-param>\r\n            <xsl:with-param name="color">\r\n              <xsl:choose>\r\n                <xsl:when test="@color">\r\n                  <xsl:value-of select="@color"/>\r\n                </xsl:when>\r\n                <xsl:otherwise>\r\n                  <xsl:value-of select="@mml:color"/>\r\n                </xsl:otherwise>\r\n              </xsl:choose>\r\n            </xsl:with-param>\r\n            <xsl:with-param name="fontsize">\r\n              <xsl:choose>\r\n                <xsl:when test="@fontsize">\r\n                  <xsl:value-of select="@fontsize"/>\r\n                </xsl:when>\r\n                <xsl:otherwise>\r\n                  <xsl:value-of select="@mml:fontsize"/>\r\n                </xsl:otherwise>\r\n              </xsl:choose>\r\n            </xsl:with-param>\r\n            <xsl:with-param name="ndCur" select="." />\r\n            <xsl:with-param name="fNor">\r\n              <xsl:call-template name="FNor">\r\n                <xsl:with-param name="ndCur" select="." />\r\n              </xsl:call-template>\r\n            </xsl:with-param>\r\n          </xsl:call-template>\r\n          <xsl:element name="m:t">\r\n            <xsl:call-template name="OutputText">\r\n              <xsl:with-param name="sInput" select="normalize-space(.)" />\r\n            </xsl:call-template>\r\n          </xsl:element>\r\n        </xsl:element>\r\n      </xsl:otherwise>\r\n    </xsl:choose>\r\n  </xsl:template>\r\n\r\n  <!-- %%Template: CreateRunWithSameProp\r\n\t-->\r\n  <xsl:template name="CreateRunWithSameProp">\r\n    <xsl:param name="mathbackground" />\r\n    <xsl:param name="mathcolor" />\r\n    <xsl:param name="mathvariant" />\r\n    <xsl:param name="color" />\r\n    <xsl:param name="font-family" />\r\n    <xsl:param name="fontsize" />\r\n    <xsl:param name="fontstyle" />\r\n    <xsl:param name="fontweight" />\r\n    <xsl:param name="mathsize" />\r\n    <xsl:param name="ndTokenFirst" />\r\n\r\n    <!--Given mathcolor, color, mstyle's (ancestor) color, and precedence of \r\n\t\t\tsaid attributes, determine the actual color of the current run-->\r\n    <xsl:variable name="sColorPropCur">\r\n      <xsl:choose>\r\n        <xsl:when test="$mathcolor!=''">\r\n          <xsl:value-of select="$mathcolor" />\r\n        </xsl:when>\r\n        <xsl:when test="$color!=''">\r\n          <xsl:value-of select="$color" />\r\n        </xsl:when>\r\n        <xsl:when test="$ndTokenFirst/ancestor::mml:mstyle[@color][1]/@color!=''">\r\n          <xsl:value-of select="$ndTokenFirst/ancestor::mml:mstyle[@color][1]/@color" />\r\n        </xsl:when>\r\n        <xsl:when test="$ndTokenFirst/ancestor::mml:mstyle[@mml:color][1]/@mml:color!=''">\r\n          <xsl:value-of select="$ndTokenFirst/ancestor::mml:mstyle[@color][1]/@mml:color" />\r\n        </xsl:when>\r\n        <xsl:otherwise>\r\n          <xsl:value-of select="''" />\r\n        </xsl:otherwise>\r\n      </xsl:choose>\r\n    </xsl:variable>\r\n\r\n    <!--Given mathsize, and fontsize and precedence of said attributes, \r\n\t\t\tdetermine the actual font size of the current run-->\r\n    <xsl:variable name="sSzCur">\r\n      <xsl:choose>\r\n        <xsl:when test="$mathsize!=''">\r\n          <xsl:value-of select="$mathsize" />\r\n        </xsl:when>\r\n        <xsl:when test="$fontsize!=''">\r\n          <xsl:value-of select="$fontsize" />\r\n        </xsl:when>\r\n        <xsl:otherwise>\r\n          <xsl:value-of select="''" />\r\n        </xsl:otherwise>\r\n      </xsl:choose>\r\n    </xsl:variable>\r\n\r\n    <!--Given mathvariant, fontstyle, and fontweight, and precedence of \r\n\t\t\tthe attributes, determine the actual font of the current run-->\r\n    <xsl:variable name="sFontCur">\r\n      <xsl:call-template name="GetFontCur">\r\n        <xsl:with-param name="mathvariant" select="$mathvariant" />\r\n        <xsl:with-param name="fontstyle" select="$fontstyle" />\r\n        <xsl:with-param name="fontweight" select="$fontweight" />\r\n        <xsl:with-param name="ndCur" select="$ndTokenFirst" />\r\n      </xsl:call-template>\r\n    </xsl:variable>\r\n\r\n    <!-- The omml equivalent structure for mml:mtext is an omml run with the run property m:nor (normal) set.\r\n         Therefore, we can only collect mtexts with  other mtext elements.  Suppose the $ndTokenFirst is an \r\n         mml:mtext, then if any of its following siblings are to be grouped, they must also be mml:text elements.  \r\n         The inverse is also true, suppose the $ndTokenFirst isn't an mml:mtext, then if any of its following siblings \r\n         are to be grouped with $ndTokenFirst, they can't be mml:mtext elements-->\r\n    <xsl:variable name="fNdTokenFirstIsMText">\r\n      <xsl:choose>\r\n        <xsl:when test="$ndTokenFirst/self::mml:mtext">1</xsl:when>\r\n        <xsl:otherwise>0</xsl:otherwise>\r\n      </xsl:choose>\r\n    </xsl:variable>\r\n\r\n    <!--In order to determine the length of the run, we will find the number of nodes before the inital node in the run and\r\n\t\t\tthe number of nodes before the first node that DOES NOT belong to the current run.  The number of nodes that will\r\n\t\t\tbe printed is One Less than the difference between the latter and the former-->\r\n\r\n    <!--Find index of current node-->\r\n    <xsl:variable name="nndBeforeFirst" select="count($ndTokenFirst/preceding-sibling::*)" />\r\n\r\n    <!--Find index of next change in run properties.\r\n\t\t\r\n\t\t    The basic idea is that we want to find the position of the last node in the longest \r\n\t\t\t\tsequence of nodes, starting from ndTokenFirst, that can be grouped into a run.  For\r\n\t\t\t\texample, nodes A and B can be grouped together into the same run iff they have the same \r\n\t\t\t\tprops.\r\n\t\t\t\t\r\n\t\t\t\tTo accomplish this grouping, we want to find the next sibling to ndTokenFirst that shouldn't be \r\n\t\t\t\tincluded in the run of text.  We do this by counting the number of elements that precede the first\r\n\t\t\t\tsuch element that doesn't belong.  The xpath that accomplishes this is below.\r\n\t\t\t\t    \r\n\t\t\t\t\t\tCount the number of siblings the precede the first element after ndTokenFirst that shouldn't belong.\r\n\t\t\t\t\t\tcount($ndTokenFirst/following-sibling::*[ . . . ][1]/preceding-sibling::*)\r\n\t\t\t\t\t\t\r\n\t\t\t\tNow, the hard part to this is what is represented by the '. . .' above.  This conditional expression is \r\n\t\t\t\tdefining what elements *don't* belong to the current run.  The conditions are as follows:\r\n\t\t\t\t\r\n\t\t\t\tThe element is not a token element (mi, mn, mo, ms, or mtext)\r\n\t\t\t\t\r\n\t\t\t\tor\r\n\t\t\t\t\r\n\t\t\t\tThe token element contains a glyph child (this is handled separately).\r\n\t\t\t\t\r\n\t\t\t\tor\r\n\t\t\t\t\r\n\t\t\t\tThe token is an mtext and the run didn't start with an mtext, or the token isn't an mtext and the run started \r\n\t\t\t\twith an mtext.  We do this check because mtext transforms into an omml m:nor property, and thus, these mtext\r\n\t\t\t\ttoken elements need to be grouped separately from other token elements.\r\n\t\t\t\t\r\n\t\t\t\t// We do an or not( . . . ), because it was easier to define what token elements match than how they don't match.\r\n\t\t\t\t// Thus, this inner '. . .' defines how token attributes equate to one another.  We add the 'not' outside of to accomplish\r\n\t\t\t\t// the goal of the outer '. . .', which is the find the next element that *doesn't* match.\r\n\t\t\t\tor not(\r\n\t\t\t\t   The background colors match.\r\n\t\t\t\t\t \r\n\t\t\t\t\t and\r\n\t\t\t\t\t \r\n\t\t\t\t\t\t\tThe current font (sFontCur) matches the mathvariant\r\n\t\t\t\t\t \r\n\t\t\t\t\t\t\tor\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tsFontCur is normal and matches the current font characteristics\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tor \r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tsFontCur is italic and matches the current font characteristics\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tor \r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t. . .\r\n\t\t\t\t\r\n\t\t\t\t\t and\r\n\t\t\t\t\t \r\n\t\t\t\t\t The font family matches the current font family.\r\n\t\t\t\t\t ) // end of not().-->\r\n    <xsl:variable name="nndBeforeLim" select="count($ndTokenFirst/following-sibling::*\r\n\t\t\t\t\t[(not(self::mml:mi) and not(self::mml:mn) and not(self::mml:mo) and not(self::mml:ms) and not(self::mml:mtext))\r\n\t\t\t\t\tor\r\n\t\t\t\t\t(self::mml:mi[child::mml:mglyph] or self::mml:mn[child::mml:mglyph] or self::mml:mo[child::mml:mglyph] or self::mml:ms[child::mml:mglyph] or self::mml:mtext[child::mml:mglyph])\r\n\t\t\t\t\tor\r\n\t\t\t\t\t(($fNdTokenFirstIsMText=1 and not(self::mml:mtext)) or ($fNdTokenFirstIsMText=0 and self::mml:mtext))\r\n\t\t\t\t\tor  \r\n\t\t\t\t\tnot(\r\n\t\t\t\t\t\t((($sFontCur=@mathvariant or $sFontCur=@mml:mathvariant)\r\n\t\t\t\t\t\t\tor\r\n\t\t\t\t\t\t\t($sFontCur='normal'\r\n\t\t\t\t\t\t\t and ((@mathvariant='normal' or @mml:mathvariant='normal')\r\n\t\t\t\t\t\t\t\t\t  or (((not(@mathvariant) or @mathvariant='') and (not(@mml:mathvariant) or @mml:mathvariant=''))\r\n\t\t\t\t\t\t\t\t\t\t\t  and (\r\n\t\t\t\t\t\t\t\t\t           ((@fontstyle='normal' or @mml:fontstyle='normal') and (not(@fontweight='bold') and not(@mml:fontweight='bold')))\r\n\t\t\t\t\t\t\t\t\t           or (self::mml:mi and string-length(normalize-space(.)) &gt; 1)\r\n\t\t\t\t\t\t\t\t\t           or (self::mml:mn and string(number(self::mml:mn/text()))='NaN')\r\n\t\t\t\t\t\t\t\t\t          )\r\n\t\t\t\t\t\t\t\t\t     )\r\n\t\t\t\t\t\t\t\t\t )\r\n\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\tor\r\n\t\t\t\t\t\t\t($sFontCur='italic' \r\n\t\t\t\t\t\t\t and ((@mathvariant='italic' or @mml:mathvariant='italic')\r\n\t\t\t\t\t\t\t\t\t  or (((not(@mathvariant) or @mathvariant='') and (not(@mml:mathvariant) or @mml:mathvariant=''))\r\n\t\t\t\t\t\t\t\t\t\t\t\tand (\r\n\t\t\t\t\t\t\t\t\t           ((@fontstyle='italic' or @mml:fontstyle='italic') and (not(@fontweight='bold') and not(@mml:fontweight='bold')))\r\n\t\t\t\t\t\t\t\t\t\t         or  \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t((self::mml:mn and string(number(self::mml:mn/text()))!='NaN')\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t or self::mml:mo\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t or (self::mml:mi and string-length(normalize-space(.)) &lt;= 1)\r\n\t\t\t\t\t\t\t\t\t            )\r\n\t\t\t\t\t\t\t\t\t          )\r\n\t\t\t\t\t\t\t\t\t     )\r\n\t\t\t\t\t\t\t\t\t )\r\n\t\t\t\t\t\t\t) \r\n\t\t\t\t\t\t\tor\r\n\t\t\t\t\t\t\t($sFontCur='bold'\r\n\t\t\t\t\t\t\t and ((@mathvariant='bold' or @mml:mathvariant='bold')\r\n\t\t\t\t\t\t\t\t\t  or (((not(@mathvariant) or @mathvariant='') and (not(@mml:mathvariant) or @mml:mathvariant=''))\r\n\t\t\t\t\t\t\t\t\t      and (\r\n\t\t\t\t\t\t\t\t\t           ((@fontweight='bold' or @mml:fontweight='bold')\r\n\t\t\t\t\t\t\t\t\t           and ((@fontstyle='normal' or @mml:fontstyle='normal') or (self::mml:mi and string-length(normalize-space(.)) &lt;= 1))\r\n\t\t\t\t\t\t\t\t\t          )\r\n\t\t\t\t\t\t\t\t\t     )\r\n\t\t\t\t\t\t\t\t\t   )  \r\n\t\t\t\t\t\t\t\t\t )\r\n\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t  or\r\n\t\t\t\t\t\t\t(($sFontCur='bi' or $sFontCur='bold-italic')\r\n\t\t\t\t\t\t\t and (\r\n\t\t\t\t\t\t\t\t\t  (@mathvariant='bold-italic' or @mml:mathvariant='bold-italic')\r\n\t\t\t\t\t\t\t\t\t  or (((not(@mathvariant) or @mathvariant='') and (not(@mml:mathvariant) or @mml:mathvariant=''))\r\n\t\t\t\t\t\t\t\t\t\t\t\tand (\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t ((@fontweight='bold' or @mml:fontweight='bold') and (@fontstyle='italic' or @mml:fontstyle='italic'))\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t or ((@fontweight='bold' or @mml:fontweight='bold')\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t  \t and (self::mml:mn \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \t\t  or self::mml:mo \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tor (self::mml:mi and string-length(normalize-space(.)) &lt;= 1)))\r\n\t\t\t\t\t\t\t\t\t          )\r\n\t\t\t\t\t\t\t\t\t     )\r\n\t\t\t\t\t\t\t\t\t )\r\n\t\t\t\t\t\t\t)\t\t     \r\n\t\t\t\t\t\t\tor\r\n              (($sFontCur='' \r\n                 and (\r\n                     ((not(@mathvariant) or @mathvariant='')\r\n                        and (not(@mml:mathvariant) or @mml:mathvariant='')\r\n                        and (not(@fontstyle) or @fontstyle='')\r\n                        and (not(@mml:fontstyle) or @mml:fontstyle='')\r\n                        and (not(@fontweight)or @fontweight='')\r\n                        and (not(@mml:fontweight) or @mml:fontweight='')\r\n\t\t              ) \r\n                      or \r\n                        (@mathvariant='italic' or @mml:mathvariant='italic')  \r\n                      or (\r\n                           ((not(@mathvariant) or @mathvariant='') and (not(@mml:mathvariant) or @mml:mathvariant=''))\r\n                               and (\r\n\t                                 (((@fontweight='normal' or @mml:fontweight='normal') \r\n\t\t                                and (@fontstyle='italic' or @mml:fontstyle='italic'))\r\n\t                                 )\r\n\t                                 or\r\n\t\t                                ((not(@fontweight) or @fontweight='') and (not(@mml:fontweight) or @mml:fontweight=''))\r\n\t\t\t                                and (@fontstyle='italic' or @mml:fontstyle='italic')\r\n\t                                 or\r\n\t\t                                ((not(@fontweight) or @fontweight='') and (not(@mml:fontweight) or @mml:fontweight=''))\r\n\t\t\t                                and (not(@fontstyle) or @fontstyle='')\r\n\t\t\t                                and (not(@mml:fontstyle) or @mml:fontstyle=''))\r\n                            )\r\n\t\t              )\r\n\r\n              ))\r\n\t\t\t\t\t\t\tor\r\n              ($sFontCur='normal' \r\n               and ((self::mml:mi \r\n                     and (not(@mathvariant) or @mathvariant='')\r\n\t                 and (not(@mml:mathvariant) or @mml:mathvariant)\r\n\t                 and (not(@fontstyle) or @fontstyle='') \r\n\t                 and (not(@mml:fontstyle) or @mml:fontstyle='')\r\n\t                 and (not(@fontweight) or @fontweight='') \r\n\t                 and (not(@mml:fontweight) or @mml:fontweight='')\r\n\t                 and (string-length(normalize-space(.)) &gt; 1)\r\n\t                 )\r\n\t                or ((self::mml:ms or self::mml:mtext) \r\n\t\t                and (not(@mathvariant) or @mathvariant='')\r\n\t\t                and (not(@mml:mathvariant) or @mml:mathvariant)\r\n\t\t                and (not(@fontstyle) or @fontstyle)\r\n\t\t                and (not(@fontstyle) or @fontstyle='')\r\n\t\t                and (not(@fontweight) or @fontweight)\r\n\t\t                and (not(@mml:fontweight) or @mml:fontweight='')\r\n\t\t                )\r\n\t                )\r\n              )\t\t\t \r\n\t\t\t\t\t\t)\r\n\t\t\t\t\t\tand\r\n            (($font-family = @font-family or $font-family = @mml:font-family)\r\n              or (($font-family='' or not($font-family))\r\n\t              and (not(@font-family) or @font-family='')\r\n\t              and (not(@mml:font-family) or @mml:font-family='')\r\n\t             ) \r\n            )\r\n\t\t\t\t\t))\r\n\t\t\t\t\t][1]/preceding-sibling::*)" />\r\n\r\n    <xsl:variable name="cndRun" select="$nndBeforeLim - $nndBeforeFirst" />\r\n\r\n    <!--Contiguous groups of like-property mi, mn, and mo's are separated by non- mi, mn, mo tags, or mi,mn, or mo\r\n\t\t\ttags with different properties.  nndBeforeLim is the number of nodes before the next tag which separates contiguous \r\n\t\t\tgroups of like-property mi, mn, and mo's.  Knowing this delimiting tag allows for the aggregation of the correct \r\n\t\t\tnumber of mi, mn, and mo tags.-->\r\n    <xsl:element name="m:r">\r\n\r\n      <!--The beginning and ending of the current run has been established. Now we should open a run element-->\r\n      <xsl:choose>\r\n\r\n        <!--If cndRun > 0, then there is a following diffrent prop, or non- Token, \r\n\t\t\t\t\t\talthough there may or may not have been a preceding different prop, or non-\r\n\t\t\t\t\t\tToken-->\r\n        <xsl:when test="$cndRun &gt; 0">\r\n          <xsl:call-template name="CreateRunProp">\r\n            <xsl:with-param name="mathvariant" select="$mathvariant" />\r\n            <xsl:with-param name="fontstyle" select="$fontstyle" />\r\n            <xsl:with-param name="fontweight" select="$fontweight" />\r\n            <xsl:with-param name="mathcolor" select="$mathcolor" />\r\n            <xsl:with-param name="mathsize" select="$mathsize" />\r\n            <xsl:with-param name="color" select="$color" />\r\n            <xsl:with-param name="fontsize" select="$fontsize" />\r\n            <xsl:with-param name="ndCur" select="$ndTokenFirst" />\r\n            <xsl:with-param name="fNor">\r\n              <xsl:call-template name="FNor">\r\n                <xsl:with-param name="ndCur" select="$ndTokenFirst" />\r\n              </xsl:call-template>\r\n            </xsl:with-param>\r\n          </xsl:call-template>\r\n          <xsl:element name="m:t">\r\n            <xsl:call-template name="OutputText">\r\n              <xsl:with-param name="sInput">\r\n                <xsl:choose>\r\n                  <xsl:when test="namespace-uri($ndTokenFirst) = 'http://www.w3.org/1998/Math/MathML' and local-name($ndTokenFirst) = 'ms'">\r\n                    <xsl:call-template name="OutputMs">\r\n                      <xsl:with-param name="msCur" select="$ndTokenFirst" />\r\n                    </xsl:call-template>\r\n                  </xsl:when>\r\n                  <xsl:otherwise>\r\n                    <xsl:value-of select="normalize-space($ndTokenFirst)" />\r\n                  </xsl:otherwise>\r\n                </xsl:choose>\r\n                <xsl:for-each select="$ndTokenFirst/following-sibling::*[position() &lt; $cndRun]">\r\n                  <xsl:choose>\r\n                    <xsl:when test="namespace-uri(.) = 'http://www.w3.org/1998/Math/MathML' and \r\n\t\t\t\t\t\t\t\t\t\t\t\t\tlocal-name(.) = 'ms'">\r\n                      <xsl:call-template name="OutputMs">\r\n                        <xsl:with-param name="msCur" select="." />\r\n                      </xsl:call-template>\r\n                    </xsl:when>\r\n                    <xsl:otherwise>\r\n                      <xsl:value-of select="normalize-space(.)" />\r\n                    </xsl:otherwise>\r\n                  </xsl:choose>\r\n                </xsl:for-each>\r\n              </xsl:with-param>\r\n            </xsl:call-template>\r\n          </xsl:element>\r\n        </xsl:when>\r\n        <xsl:otherwise>\r\n\r\n          <!--if cndRun lt;= 0, then iNextNonToken = 0, \r\n\t\t\t\t\t\tand iPrecNonToken gt;= 0.  In either case, b/c there \r\n\t\t\t\t\t\tis no next different property or non-Token \r\n\t\t\t\t\t\t(which is implied by the nndBeforeLast being equal to 0) \r\n\t\t\t\t\t\tyou can put all the remaining mi, mn, and mo's into one \r\n\t\t\t\t\t\tgroup.-->\r\n          <xsl:call-template name="CreateRunProp">\r\n            <xsl:with-param name="mathvariant" select="$mathvariant" />\r\n            <xsl:with-param name="fontstyle" select="$fontstyle" />\r\n            <xsl:with-param name="fontweight" select="$fontweight" />\r\n            <xsl:with-param name="mathcolor" select="$mathcolor" />\r\n            <xsl:with-param name="mathsize" select="$mathsize" />\r\n            <xsl:with-param name="color" select="$color" />\r\n            <xsl:with-param name="fontsize" select="$fontsize" />\r\n            <xsl:with-param name="ndCur" select="$ndTokenFirst" />\r\n            <xsl:with-param name="fNor">\r\n              <xsl:call-template name="FNor">\r\n                <xsl:with-param name="ndCur" select="$ndTokenFirst" />\r\n              </xsl:call-template>\r\n            </xsl:with-param>\r\n          </xsl:call-template>\r\n          <xsl:element name="m:t">\r\n\r\n            <!--Create the Run, first output current, then in a \r\n\t\t\t\t\t\t\tfor-each, because all the following siblings are\r\n\t\t\t\t\t\t\tmn, mi, and mo's that conform to the run's properties,\r\n\t\t\t\t\t\t\tgroup them together-->\r\n            <xsl:call-template name="OutputText">\r\n              <xsl:with-param name="sInput">\r\n                <xsl:choose>\r\n                  <xsl:when test="namespace-uri($ndTokenFirst) = 'http://www.w3.org/1998/Math/MathML' and \r\n\t\t\t\t\t\t\t\t\t\t\t\t\tlocal-name($ndTokenFirst) = 'ms'">\r\n                    <xsl:call-template name="OutputMs">\r\n                      <xsl:with-param name="msCur" select="$ndTokenFirst" />\r\n                    </xsl:call-template>\r\n                  </xsl:when>\r\n                  <xsl:otherwise>\r\n                    <xsl:value-of select="normalize-space($ndTokenFirst)" />\r\n                  </xsl:otherwise>\r\n                </xsl:choose>\r\n                <xsl:for-each select="$ndTokenFirst/following-sibling::*[self::mml:mi or self::mml:mn or self::mml:mo or self::mml:ms or self::mml:mtext]">\r\n                  <xsl:choose>\r\n                    <xsl:when test="namespace-uri(.) = 'http://www.w3.org/1998/Math/MathML' and \r\n\t\t\t\t\t\t\t\t\t\t\t\t\tlocal-name(.) = 'ms'">\r\n                      <xsl:call-template name="OutputMs">\r\n                        <xsl:with-param name="msCur" select="." />\r\n                      </xsl:call-template>\r\n                    </xsl:when>\r\n                    <xsl:otherwise>\r\n                      <xsl:value-of select="normalize-space(.)" />\r\n                    </xsl:otherwise>\r\n                  </xsl:choose>\r\n                </xsl:for-each>\r\n              </xsl:with-param>\r\n            </xsl:call-template>\r\n          </xsl:element>\r\n        </xsl:otherwise>\r\n      </xsl:choose>\r\n    </xsl:element>\r\n\r\n    <!--The run was terminated by an mi, mn, mo, ms, or mtext with different properties, \r\n\t\t\t\ttherefore, call-template CreateRunWithSameProp, using cndRun+1 node as new start node-->\r\n    <xsl:if test="$nndBeforeLim!=0 \r\n           and ($ndTokenFirst/following-sibling::*[$cndRun]/self::mml:mi or \r\n\t\t\t\t\t      $ndTokenFirst/following-sibling::*[$cndRun]/self::mml:mn or\r\n\t\t\t\t\t      $ndTokenFirst/following-sibling::*[$cndRun]/self::mml:mo or\r\n\t\t\t\t\t      $ndTokenFirst/following-sibling::*[$cndRun]/self::mml:ms or\r\n                $ndTokenFirst/following-sibling::*[$cndRun]/self::mml:mtext) \r\n            and (count($ndTokenFirst/following-sibling::*[$cndRun]/mml:mglyph) = 0)">\r\n      <xsl:call-template name="CreateRunWithSameProp">\r\n        <xsl:with-param name="mathbackground">\r\n          <xsl:choose>\r\n            <xsl:when test="$ndTokenFirst/following-sibling::*[$cndRun]/@mathbackground">\r\n              <xsl:value-of select="$ndTokenFirst/following-sibling::*[$cndRun]/@mathbackground"/>\r\n            </xsl:when>\r\n            <xsl:otherwise>\r\n              <xsl:value-of select="$ndTokenFirst/following-sibling::*[$cndRun]/@mml:mathbackground"/>\r\n            </xsl:otherwise>\r\n          </xsl:choose>\r\n        </xsl:with-param>\r\n        <xsl:with-param name="mathcolor">\r\n          <xsl:choose>\r\n            <xsl:when test="$ndTokenFirst/following-sibling::*[$cndRun]/@mathcolor">\r\n              <xsl:value-of select="$ndTokenFirst/following-sibling::*[$cndRun]/@mathcolor"/>\r\n            </xsl:when>\r\n            <xsl:otherwise>\r\n              <xsl:value-of select="$ndTokenFirst/following-sibling::*[$cndRun]/@mml:mathcolor"/>\r\n            </xsl:otherwise>\r\n          </xsl:choose>\r\n        </xsl:with-param>\r\n        <xsl:with-param name="mathvariant">\r\n          <xsl:choose>\r\n            <xsl:when test="$ndTokenFirst/following-sibling::*[$cndRun]/@mathvariant">\r\n              <xsl:value-of select="$ndTokenFirst/following-sibling::*[$cndRun]/@mathvariant"/>\r\n            </xsl:when>\r\n            <xsl:otherwise>\r\n              <xsl:value-of select="$ndTokenFirst/following-sibling::*[$cndRun]/@mml:mathvariant"/>\r\n            </xsl:otherwise>\r\n          </xsl:choose>\r\n        </xsl:with-param>\r\n        <xsl:with-param name="color">\r\n          <xsl:choose>\r\n            <xsl:when test="$ndTokenFirst/following-sibling::*[$cndRun]/@color">\r\n              <xsl:value-of select="$ndTokenFirst/following-sibling::*[$cndRun]/@color"/>\r\n            </xsl:when>\r\n            <xsl:otherwise>\r\n              <xsl:value-of select="$ndTokenFirst/following-sibling::*[$cndRun]/@mml:color"/>\r\n            </xsl:otherwise>\r\n          </xsl:choose>\r\n        </xsl:with-param>\r\n        <xsl:with-param name="font-family">\r\n          <xsl:choose>\r\n            <xsl:when test="$ndTokenFirst/following-sibling::*[$cndRun]/@font-family">\r\n              <xsl:value-of select="$ndTokenFirst/following-sibling::*[$cndRun]/@font-family"/>\r\n            </xsl:when>\r\n            <xsl:otherwise>\r\n              <xsl:value-of select="$ndTokenFirst/following-sibling::*[$cndRun]/@mml:font-family"/>\r\n            </xsl:otherwise>\r\n          </xsl:choose>\r\n        </xsl:with-param>\r\n        <xsl:with-param name="fontsize">\r\n          <xsl:choose>\r\n            <xsl:when test="$ndTokenFirst/following-sibling::*[$cndRun]/@fontsize">\r\n              <xsl:value-of select="$ndTokenFirst/following-sibling::*[$cndRun]/@fontsize"/>\r\n            </xsl:when>\r\n            <xsl:otherwise>\r\n              <xsl:value-of select="$ndTokenFirst/following-sibling::*[$cndRun]/@mml:fontsize"/>\r\n            </xsl:otherwise>\r\n          </xsl:choose>\r\n        </xsl:with-param>\r\n        <xsl:with-param name="fontstyle">\r\n          <xsl:choose>\r\n            <xsl:when test="$ndTokenFirst/following-sibling::*[$cndRun]/@fontstyle">\r\n              <xsl:value-of select="$ndTokenFirst/following-sibling::*[$cndRun]/@fontstyle"/>\r\n            </xsl:when>\r\n            <xsl:otherwise>\r\n              <xsl:value-of select="$ndTokenFirst/following-sibling::*[$cndRun]/@mml:fontstyle"/>\r\n            </xsl:otherwise>\r\n          </xsl:choose>\r\n        </xsl:with-param>\r\n        <xsl:with-param name="fontweight">\r\n          <xsl:choose>\r\n            <xsl:when test="$ndTokenFirst/following-sibling::*[$cndRun]/@fontweight">\r\n              <xsl:value-of select="$ndTokenFirst/following-sibling::*[$cndRun]/@fontweight"/>\r\n            </xsl:when>\r\n            <xsl:otherwise>\r\n              <xsl:value-of select="$ndTokenFirst/following-sibling::*[$cndRun]/@mml:fontweight"/>\r\n            </xsl:otherwise>\r\n          </xsl:choose>\r\n        </xsl:with-param>\r\n        <xsl:with-param name="mathsize">\r\n          <xsl:choose>\r\n            <xsl:when test="$ndTokenFirst/following-sibling::*[$cndRun]/@mathsize">\r\n              <xsl:value-of select="$ndTokenFirst/following-sibling::*[$cndRun]/@mathsize"/>\r\n            </xsl:when>\r\n            <xsl:otherwise>\r\n              <xsl:value-of select="$ndTokenFirst/following-sibling::*[$cndRun]/@mml:mathsize"/>\r\n            </xsl:otherwise>\r\n          </xsl:choose>\r\n        </xsl:with-param>\r\n        <xsl:with-param name="ndTokenFirst" select="$ndTokenFirst/following-sibling::*[$cndRun]" />\r\n      </xsl:call-template>\r\n    </xsl:if>\r\n  </xsl:template>\r\n\r\n  <!-- %%Template: FNor\r\n\t\t\t\t Given the context of ndCur, determine if ndCur should be omml's normal style.\r\n\t-->\r\n  <xsl:template name="FNor">\r\n    <xsl:param name="ndCur" select="." />\r\n    <xsl:choose>\r\n      <!-- Is the current node an mml:mtext, or if this is an mglyph whose parent is \r\n             an mml:mtext. -->\r\n      <xsl:when test="$ndCur/self::mml:mtext or ($ndCur/self::mml:mglyph and parent::mml:mtext)">1</xsl:when>\r\n      <xsl:otherwise>0</xsl:otherwise>\r\n    </xsl:choose>\r\n  </xsl:template>\r\n\r\n\r\n  <!-- %%Template: CreateRunProp\r\n\t-->\r\n  <xsl:template name="CreateRunProp">\r\n    <xsl:param name="mathbackground" />\r\n    <xsl:param name="mathcolor" />\r\n    <xsl:param name="mathvariant" />\r\n    <xsl:param name="color" />\r\n    <xsl:param name="font-family" />\r\n    <xsl:param name="fontsize" />\r\n    <xsl:param name="fontstyle" />\r\n    <xsl:param name="fontweight" />\r\n    <xsl:param name="mathsize" />\r\n    <xsl:param name="ndCur" />\r\n    <xsl:param name="fontfamily" />\r\n    <xsl:param name="fNor" />\r\n    <xsl:variable name="mstyleColor">\r\n      <xsl:if test="not(not($ndCur))">\r\n        <xsl:choose>\r\n          <xsl:when test="$ndCur/ancestor::mml:mstyle[@color][1]/@color">\r\n            <xsl:value-of select="$ndCur/ancestor::mml:mstyle[@color][1]/@color"/>\r\n          </xsl:when>\r\n          <xsl:otherwise>\r\n            <xsl:value-of select="$ndCur/ancestor::mml:mstyle[@color][1]/@mml:color"/>\r\n          </xsl:otherwise>\r\n        </xsl:choose>\r\n      </xsl:if>\r\n    </xsl:variable>\r\n    <xsl:call-template name="CreateMathRPR">\r\n      <xsl:with-param name="mathvariant" select="$mathvariant" />\r\n      <xsl:with-param name="fontstyle" select="$fontstyle" />\r\n      <xsl:with-param name="fontweight" select="$fontweight" />\r\n      <xsl:with-param name="ndCur" select="$ndCur" />\r\n      <xsl:with-param name="fNor" select="$fNor" />\r\n    </xsl:call-template>\r\n  </xsl:template>\r\n\r\n  <!-- %%Template: CreateMathRPR\r\n\t-->\r\n  <xsl:template name="CreateMathRPR">\r\n    <xsl:param name="mathvariant" />\r\n    <xsl:param name="fontstyle" />\r\n    <xsl:param name="fontweight" />\r\n    <xsl:param name="ndCur" />\r\n    <xsl:param name="fNor" />\r\n    <xsl:variable name="sFontCur">\r\n      <xsl:call-template name="GetFontCur">\r\n        <xsl:with-param name="mathvariant" select="$mathvariant" />\r\n        <xsl:with-param name="fontstyle" select="$fontstyle" />\r\n        <xsl:with-param name="fontweight" select="$fontweight" />\r\n        <xsl:with-param name="ndCur" select="$ndCur" />\r\n      </xsl:call-template>\r\n    </xsl:variable>\r\n    <xsl:if test="$fNor=1 or ($sFontCur!='italic' and $sFontCur!='')">\r\n      <xsl:element name="m:rPr">\r\n        <xsl:if test="$fNor=1">\r\n          <m:nor />\r\n        </xsl:if>\r\n        <xsl:call-template name="CreateMathScrStyProp">\r\n          <xsl:with-param name="font" select="$sFontCur" />\r\n          <xsl:with-param name="fNor" select="$fNor" />\r\n        </xsl:call-template>\r\n      </xsl:element>\r\n    </xsl:if>\r\n  </xsl:template>\r\n\r\n  <!-- %%Template: GetFontCur\r\n\t-->\r\n  <xsl:template name="GetFontCur">\r\n    <xsl:param name="ndCur" />\r\n    <xsl:param name="mathvariant" />\r\n    <xsl:param name="fontstyle" />\r\n    <xsl:param name="fontweight" />\r\n    <xsl:choose>\r\n      <xsl:when test="$mathvariant!=''">\r\n        <xsl:value-of select="$mathvariant" />\r\n      </xsl:when>\r\n      <xsl:when test="not($ndCur)">\r\n        <xsl:value-of select="'italic'" />\r\n      </xsl:when>\r\n      <xsl:when test="$ndCur/self::mml:mi and (string-length(normalize-space($ndCur)) &lt;= 1)\r\n\t\t\t\t\t\t\t\t      or $ndCur/self::mml:mn and string(number($ndCur/text()))!='NaN'\r\n\t\t\t\t\t\t\t\t      or $ndCur/self::mml:mo">\r\n\r\n        <!-- The default for the above three cases is fontstyle=italic fontweight=normal.-->\r\n        <xsl:choose>\r\n          <xsl:when test="$fontstyle='normal' and $fontweight='bold'">\r\n            <!-- In omml, a sty of 'b' (which is what bold is translated into)\r\n\t\t\t\t\t\t     implies a normal fontstyle -->\r\n            <xsl:value-of select="'bold'" />\r\n          </xsl:when>\r\n          <xsl:when test="$fontstyle='normal'">\r\n            <xsl:value-of select="'normal'" />\r\n          </xsl:when>\r\n          <xsl:when test="$fontweight='bold'">\r\n            <xsl:value-of select="'bi'" />\r\n          </xsl:when>\r\n          <xsl:otherwise>\r\n            <xsl:value-of select="'italic'" />\r\n          </xsl:otherwise>\r\n        </xsl:choose>\r\n      </xsl:when>\r\n      <xsl:otherwise>\r\n        <!--Default is fontweight = 'normal' and fontstyle='normal'-->\r\n        <xsl:choose>\r\n          <xsl:when test="$fontstyle='italic' and $fontweight='bold'">\r\n            <xsl:value-of select="'bi'" />\r\n          </xsl:when>\r\n          <xsl:when test="$fontstyle='italic'">\r\n            <xsl:value-of select="'italic'" />\r\n          </xsl:when>\r\n          <xsl:when test="$fontweight='bold'">\r\n            <xsl:value-of select="'bold'" />\r\n          </xsl:when>\r\n          <xsl:otherwise>\r\n            <xsl:value-of select="'normal'" />\r\n          </xsl:otherwise>\r\n        </xsl:choose>\r\n      </xsl:otherwise>\r\n    </xsl:choose>\r\n  </xsl:template>\r\n\r\n\r\n  <!-- %%Template: CreateMathScrStyProp\r\n\t-->\r\n  <xsl:template name="CreateMathScrStyProp">\r\n    <xsl:param name="font" />\r\n    <xsl:param name="fNor" select="0"/>\r\n    <xsl:choose>\r\n      <xsl:when test="$font='normal' and $fNor=0">\r\n        <xsl:element name="m:sty">\r\n          <xsl:attribute name="m:val">p</xsl:attribute>\r\n        </xsl:element>\r\n      </xsl:when>\r\n      <xsl:when test="$font='bold'">\r\n        <xsl:element name="m:sty">\r\n          <xsl:attribute name="m:val">b</xsl:attribute>\r\n        </xsl:element>\r\n      </xsl:when>\r\n      <xsl:when test="$font='italic'">\r\n      </xsl:when>\r\n      <xsl:when test="$font='script'">\r\n        <xsl:element name="m:scr">\r\n          <xsl:attribute name="m:val">script</xsl:attribute>\r\n        </xsl:element>\r\n      </xsl:when>\r\n      <xsl:when test="$font='bold-script'">\r\n        <xsl:element name="m:scr">\r\n          <xsl:attribute name="m:val">script</xsl:attribute>\r\n        </xsl:element>\r\n        <xsl:element name="m:sty">\r\n          <xsl:attribute name="m:val">b</xsl:attribute>\r\n        </xsl:element>\r\n      </xsl:when>\r\n      <xsl:when test="$font='double-struck'">\r\n        <xsl:element name="m:scr">\r\n          <xsl:attribute name="m:val">double-struck</xsl:attribute>\r\n        </xsl:element>\r\n        <xsl:element name="m:sty">\r\n          <xsl:attribute name="m:val">p</xsl:attribute>\r\n        </xsl:element>\r\n      </xsl:when>\r\n      <xsl:when test="$font='fraktur'">\r\n        <xsl:element name="m:scr">\r\n          <xsl:attribute name="m:val">fraktur</xsl:attribute>\r\n        </xsl:element>\r\n        <xsl:element name="m:sty">\r\n          <xsl:attribute name="m:val">p</xsl:attribute>\r\n        </xsl:element>\r\n      </xsl:when>\r\n      <xsl:when test="$font='bold-fraktur'">\r\n        <xsl:element name="m:scr">\r\n          <xsl:attribute name="m:val">fraktur</xsl:attribute>\r\n        </xsl:element>\r\n        <xsl:element name="m:sty">\r\n          <xsl:attribute name="m:val">b</xsl:attribute>\r\n        </xsl:element>\r\n      </xsl:when>\r\n      <xsl:when test="$font='sans-serif'">\r\n        <xsl:element name="m:scr">\r\n          <xsl:attribute name="m:val">sans-serif</xsl:attribute>\r\n        </xsl:element>\r\n        <xsl:element name="m:sty">\r\n          <xsl:attribute name="m:val">p</xsl:attribute>\r\n        </xsl:element>\r\n      </xsl:when>\r\n      <xsl:when test="$font='bold-sans-serif'">\r\n        <xsl:element name="m:scr">\r\n          <xsl:attribute name="m:val">sans-serif</xsl:attribute>\r\n        </xsl:element>\r\n        <xsl:element name="m:sty">\r\n          <xsl:attribute name="m:val">b</xsl:attribute>\r\n        </xsl:element>\r\n      </xsl:when>\r\n      <xsl:when test="$font='sans-serif-italic'">\r\n        <xsl:element name="m:scr">\r\n          <xsl:attribute name="m:val">sans-serif</xsl:attribute>\r\n        </xsl:element>\r\n      </xsl:when>\r\n      <xsl:when test="$font='sans-serif-bold-italic'">\r\n        <xsl:element name="m:scr">\r\n          <xsl:attribute name="m:val">sans-serif</xsl:attribute>\r\n        </xsl:element>\r\n        <xsl:element name="m:sty">\r\n          <xsl:attribute name="m:val">bi</xsl:attribute>\r\n        </xsl:element>\r\n      </xsl:when>\r\n      <xsl:when test="$font='monospace'" />\r\n      <!-- We can't do monospace, so leave empty -->\r\n      <xsl:when test="$font='bold'">\r\n        <xsl:element name="m:sty">\r\n          <xsl:attribute name="m:val">b</xsl:attribute>\r\n        </xsl:element>\r\n      </xsl:when>\r\n      <xsl:when test="$font='bi' or $font='bold-italic'">\r\n        <xsl:element name="m:sty">\r\n          <xsl:attribute name="m:val">bi</xsl:attribute>\r\n        </xsl:element>\r\n      </xsl:when>\r\n    </xsl:choose>\r\n  </xsl:template>\r\n\r\n  <xsl:template name="FBar">\r\n    <xsl:param name="sLineThickness" />\r\n    <xsl:variable name="sLowerLineThickness" select="translate($sLineThickness, $StrUCAlphabet, $StrLCAlphabet)" />\r\n    <xsl:choose>\r\n      <xsl:when test="string-length($sLowerLineThickness)=0\r\n                      or $sLowerLineThickness='thin' \r\n                      or $sLowerLineThickness='medium' \r\n                      or $sLowerLineThickness='thick'">1</xsl:when>\r\n      <xsl:otherwise>\r\n        <xsl:variable name="fStrContainsNonZeroDigit">\r\n          <xsl:call-template name="FStrContainsNonZeroDigit">\r\n            <xsl:with-param name="s" select="$sLowerLineThickness" />\r\n          </xsl:call-template>\r\n        </xsl:variable>\r\n        <xsl:choose>\r\n          <xsl:when test="$fStrContainsNonZeroDigit=1">1</xsl:when>\r\n          <xsl:otherwise>0</xsl:otherwise>\r\n        </xsl:choose>\r\n      </xsl:otherwise>\r\n    </xsl:choose>\r\n  </xsl:template>\r\n\r\n\r\n  <!-- %%Template: match mfrac \r\n\t\t-->\r\n  <xsl:template match="mml:mfrac">\r\n    <xsl:variable name="fBar">\r\n      <xsl:call-template name="FBar">\r\n        <xsl:with-param name="sLineThickness">\r\n          <xsl:choose>\r\n            <xsl:when test="@linethickness">\r\n              <xsl:value-of select="@linethickness"/>\r\n            </xsl:when>\r\n            <xsl:otherwise>\r\n              <xsl:value-of select="@mml:linethickness"/>\r\n            </xsl:otherwise>\r\n          </xsl:choose>\r\n        </xsl:with-param>\r\n      </xsl:call-template>\r\n    </xsl:variable>\r\n\r\n    <xsl:element name="m:f">\r\n      <xsl:element name="m:fPr">\r\n        <xsl:element name="m:type">\r\n          <xsl:attribute name="m:val">\r\n            <xsl:choose>\r\n              <xsl:when test="$fBar=0">noBar</xsl:when>\r\n              <xsl:when test="@bevelled='true' or @mml:bevelled='true'">skw</xsl:when>\r\n              <xsl:otherwise>bar</xsl:otherwise>\r\n            </xsl:choose>\r\n          </xsl:attribute>\r\n        </xsl:element>\r\n      </xsl:element>\r\n      <xsl:element name="m:num">\r\n        <xsl:call-template name="CreateArgProp" />\r\n        <xsl:apply-templates select="child::*[1]" />\r\n      </xsl:element>\r\n      <xsl:element name="m:den">\r\n        <xsl:call-template name="CreateArgProp" />\r\n        <xsl:apply-templates select="child::*[2]" />\r\n      </xsl:element>\r\n    </xsl:element>\r\n  </xsl:template>\r\n\r\n  <!-- %%Template: match menclose msqrt\r\n\t-->\r\n  <xsl:template match="mml:menclose | mml:msqrt">\r\n    <xsl:variable name="sLowerCaseNotation">\r\n      <xsl:choose>\r\n        <xsl:when test="@notation">\r\n          <xsl:value-of select="translate(@notation, $StrUCAlphabet, $StrLCAlphabet)"/>\r\n        </xsl:when>\r\n        <xsl:otherwise>\r\n          <xsl:value-of select="translate(@mml:notation, $StrUCAlphabet, $StrLCAlphabet)"/>\r\n        </xsl:otherwise>\r\n      </xsl:choose>\r\n    </xsl:variable>\r\n    <xsl:choose>\r\n      <!-- Take care of default -->\r\n      <xsl:when test="$sLowerCaseNotation='radical' \r\n                      or not($sLowerCaseNotation) \r\n                      or $sLowerCaseNotation='' \r\n                      or self::mml:msqrt">\r\n        <xsl:element name="m:rad">\r\n          <xsl:element name="m:radPr">\r\n            <xsl:element name="m:degHide">\r\n              <xsl:attribute name="m:val">on</xsl:attribute>\r\n            </xsl:element>\r\n          </xsl:element>\r\n          <xsl:element name="m:deg">\r\n            <xsl:call-template name="CreateArgProp" />\r\n          </xsl:element>\r\n          <xsl:element name="m:e">\r\n            <xsl:call-template name="CreateArgProp" />\r\n            <xsl:apply-templates select="*" />\r\n          </xsl:element>\r\n        </xsl:element>\r\n      </xsl:when>\r\n      <xsl:otherwise>\r\n        <xsl:choose>\r\n          <xsl:when test="$sLowerCaseNotation='actuarial' or $sLowerCaseNotation='longdiv'" />\r\n          <xsl:otherwise>\r\n            <xsl:element name="m:borderBox">\r\n              <!-- Dealing with more complex notation attribute -->\r\n              <xsl:variable name="fBox">\r\n                <xsl:choose>\r\n                  <!-- Word doesn't have circle and roundedbox concepts, therefore, map both to a \r\n                       box. -->\r\n                  <xsl:when test="contains($sLowerCaseNotation, 'box')\r\n                                  or contains($sLowerCaseNotation, 'circle')\r\n                                  or contains($sLowerCaseNotation, 'roundedbox')">1</xsl:when>\r\n                  <xsl:otherwise>0</xsl:otherwise>\r\n                </xsl:choose>\r\n              </xsl:variable>\r\n              <xsl:variable name="fTop">\r\n                <xsl:choose>\r\n                  <xsl:when test="contains($sLowerCaseNotation, 'top')">1</xsl:when>\r\n                  <xsl:otherwise>0</xsl:otherwise>\r\n                </xsl:choose>\r\n              </xsl:variable>\r\n              <xsl:variable name="fBot">\r\n                <xsl:choose>\r\n                  <xsl:when test="contains($sLowerCaseNotation, 'bottom')">1</xsl:when>\r\n                  <xsl:otherwise>0</xsl:otherwise>\r\n                </xsl:choose>\r\n              </xsl:variable>\r\n              <xsl:variable name="fLeft">\r\n                <xsl:choose>\r\n                  <xsl:when test="contains($sLowerCaseNotation, 'left')">1</xsl:when>\r\n                  <xsl:otherwise>0</xsl:otherwise>\r\n                </xsl:choose>\r\n              </xsl:variable>\r\n              <xsl:variable name="fRight">\r\n                <xsl:choose>\r\n                  <xsl:when test="contains($sLowerCaseNotation, 'right')">1</xsl:when>\r\n                  <xsl:otherwise>0</xsl:otherwise>\r\n                </xsl:choose>\r\n              </xsl:variable>\r\n              <xsl:variable name="fStrikeH">\r\n                <xsl:choose>\r\n                  <xsl:when test="contains($sLowerCaseNotation, 'horizontalstrike')">1</xsl:when>\r\n                  <xsl:otherwise>0</xsl:otherwise>\r\n                </xsl:choose>\r\n              </xsl:variable>\r\n              <xsl:variable name="fStrikeV">\r\n                <xsl:choose>\r\n                  <xsl:when test="contains($sLowerCaseNotation, 'verticalstrike')">1</xsl:when>\r\n                  <xsl:otherwise>0</xsl:otherwise>\r\n                </xsl:choose>\r\n              </xsl:variable>\r\n              <xsl:variable name="fStrikeBLTR">\r\n                <xsl:choose>\r\n                  <xsl:when test="contains($sLowerCaseNotation, 'updiagonalstrike')">1</xsl:when>\r\n                  <xsl:otherwise>0</xsl:otherwise>\r\n                </xsl:choose>\r\n              </xsl:variable>\r\n              <xsl:variable name="fStrikeTLBR">\r\n                <xsl:choose>\r\n                  <xsl:when test="contains($sLowerCaseNotation, 'downdiagonalstrike')">1</xsl:when>\r\n                  <xsl:otherwise>0</xsl:otherwise>\r\n                </xsl:choose>\r\n              </xsl:variable>\r\n\r\n              <!-- Should we create borderBoxPr? \r\n                   We should if the enclosure isn't Word's default, which is\r\n                   a plain box -->\r\n              <xsl:if test="$fStrikeH=1 \r\n                          or $fStrikeV=1\r\n                          or $fStrikeBLTR=1 \r\n                          or $fStrikeTLBR=1\r\n                          or ($fBox=0\r\n                              and not($fTop=1 \r\n                                      and $fBot=1\r\n                                      and $fLeft=1\r\n                                      and $fRight=1)\r\n                              )">\r\n                <xsl:element name="m:borderBoxPr">\r\n                  <xsl:if test="$fBox=0">\r\n                    <xsl:if test="$fTop=0">\r\n                      <xsl:element name="m:hideTop">\r\n                        <xsl:attribute name="m:val">on</xsl:attribute>\r\n                      </xsl:element>\r\n                    </xsl:if>\r\n                    <xsl:if test="$fBot=0">\r\n                      <xsl:element name="m:hideBot">\r\n                        <xsl:attribute name="m:val">on</xsl:attribute>\r\n                      </xsl:element>\r\n                    </xsl:if>\r\n                    <xsl:if test="$fLeft=0">\r\n                      <xsl:element name="m:hideLeft">\r\n                        <xsl:attribute name="m:val">on</xsl:attribute>\r\n                      </xsl:element>\r\n                    </xsl:if>\r\n                    <xsl:if test="$fRight=0">\r\n                      <xsl:element name="m:hideRight">\r\n                        <xsl:attribute name="m:val">on</xsl:attribute>\r\n                      </xsl:element>\r\n                    </xsl:if>\r\n                  </xsl:if>\r\n                  <xsl:if test="$fStrikeH=1">\r\n                    <xsl:element name="m:strikeH">\r\n                      <xsl:attribute name="m:val">on</xsl:attribute>\r\n                    </xsl:element>\r\n                  </xsl:if>\r\n                  <xsl:if test="$fStrikeV=1">\r\n                    <xsl:element name="m:strikeV">\r\n                      <xsl:attribute name="m:val">on</xsl:attribute>\r\n                    </xsl:element>\r\n                  </xsl:if>\r\n                  <xsl:if test="$fStrikeBLTR=1">\r\n                    <xsl:element name="m:strikeBLTR">\r\n                      <xsl:attribute name="m:val">on</xsl:attribute>\r\n                    </xsl:element>\r\n                  </xsl:if>\r\n                  <xsl:if test="$fStrikeTLBR=1">\r\n                    <xsl:element name="m:strikeTLBR">\r\n                      <xsl:attribute name="m:val">on</xsl:attribute>\r\n                    </xsl:element>\r\n                  </xsl:if>\r\n                </xsl:element>\r\n              </xsl:if>\r\n              <xsl:element name="m:e">\r\n                <xsl:call-template name="CreateArgProp" />\r\n                <xsl:apply-templates select="*" />\r\n              </xsl:element>\r\n            </xsl:element>\r\n          </xsl:otherwise>\r\n        </xsl:choose>\r\n      </xsl:otherwise>\r\n    </xsl:choose>\r\n  </xsl:template>\r\n\r\n  <!-- %%Template: CreateArgProp\r\n\t-->\r\n  <xsl:template name="CreateArgProp">\r\n    <xsl:if test="not(count(ancestor-or-self::mml:mstyle[@scriptlevel='0' or @scriptlevel='1' or @scriptlevel='2'])=0)\r\n                  or not(count(ancestor-or-self::mml:mstyle[@mml:scriptlevel='0' or @mml:scriptlevel='1' or @mml:scriptlevel='2'])=0)">\r\n      <xsl:element name="m:argPr">\r\n        <xsl:element name="m:scrLvl">\r\n          <xsl:attribute name="m:val">\r\n            <xsl:choose>\r\n              <xsl:when test="ancestor-or-self::mml:mstyle[@scriptlevel][1]/@scriptlevel">\r\n                <xsl:value-of select="ancestor-or-self::mml:mstyle[@scriptlevel][1]/@scriptlevel"/>\r\n              </xsl:when>\r\n              <xsl:otherwise>\r\n                <xsl:value-of select="ancestor-or-self::mml:mstyle[@scriptlevel][1]/@mml:scriptlevel"/>\r\n              </xsl:otherwise>\r\n            </xsl:choose>\r\n          </xsl:attribute>\r\n        </xsl:element>\r\n      </xsl:element>\r\n    </xsl:if>\r\n  </xsl:template>\r\n\r\n  <!-- %%Template: match mroot\r\n\t-->\r\n  <xsl:template match="mml:mroot">\r\n    <xsl:element name="m:rad">\r\n      <xsl:element name="m:radPr">\r\n        <xsl:element name="m:degHide">\r\n          <xsl:attribute name="m:val">off</xsl:attribute>\r\n        </xsl:element>\r\n      </xsl:element>\r\n      <xsl:element name="m:deg">\r\n        <xsl:call-template name="CreateArgProp" />\r\n        <xsl:apply-templates select="child::*[2]" />\r\n      </xsl:element>\r\n      <xsl:element name="m:e">\r\n        <xsl:call-template name="CreateArgProp" />\r\n        <xsl:apply-templates select="child::*[1]" />\r\n      </xsl:element>\r\n    </xsl:element>\r\n  </xsl:template>\r\n\r\n  <!-- MathML has no concept of a linear fraction.  When transforming a linear fraction\r\n       from Omml to MathML, we create the following MathML:\r\n       \r\n       <mml:mrow>\r\n         <mml:mrow>\r\n            // numerator\r\n         </mml:mrow>\r\n         <mml:mo>/</mml:mo>\r\n         <mml:mrow>\r\n            // denominator\r\n         </mml:mrow>\r\n       </mml:mrow>\r\n       \r\n       This template looks for four things:\r\n          1.  ndCur is an mml:mrow\r\n          2.  ndCur has three children\r\n          3.  The second child is an <mml:mo>\r\n          4.  The second child's text is '/'\r\n       \r\n       -->\r\n  <xsl:template name="FLinearFrac">\r\n    <xsl:param name="ndCur" select="." />\r\n    <xsl:variable name="sNdText">\r\n      <xsl:value-of select="normalize-space($ndCur/*[2])"/>\r\n    </xsl:variable>\r\n\r\n    <xsl:choose>\r\n      <!-- I spy a linear fraction -->\r\n      <xsl:when test="$ndCur/self::mml:mrow\r\n                      and count($ndCur/*)=3\r\n                      and $ndCur/*[2][self::mml:mo]\r\n                      and $sNdText='/'">1</xsl:when>\r\n      <xsl:otherwise>0</xsl:otherwise>\r\n    </xsl:choose>\r\n  </xsl:template>\r\n\r\n\r\n  <!-- Though presentation mathml can certainly typeset any generic function with the\r\n\t     appropriate function operator spacing, presentation MathML has no concept of \r\n\t\t\t a function structure like omml does.  In order to preserve the omml <func> \r\n\t\t\t element, we must establish how an omml <func> element looks in mml.  This \r\n\t\t\t is shown below:\r\n       \r\n       <mml:mrow>\r\n         <mml:mrow>\r\n            // function name\r\n         </mml:mrow>\r\n         <mml:mo>&#x02061;</mml:mo>\r\n         <mml:mrow>\r\n            // function argument\r\n         </mml:mrow>\r\n       </mml:mrow>\r\n       \r\n       This template looks for six things to be true:\r\n\t\t\t\t\t1.  ndCur is an mml:mrow\r\n\t\t\t\t\t2.  ndCur has three children\r\n\t\t\t\t\t3.  The first child is an <mml:mrow>\r\n\t\t\t\t\t4.  The second child is an <mml:mo>\r\n\t\t\t\t\t5.  The third child is an <mml:mrow>\r\n\t\t\t\t\t6.  The second child's text is '&#x02061;'\r\n       -->\r\n  <xsl:template name="FIsFunc">\r\n    <xsl:param name="ndCur" select="." />\r\n    <xsl:variable name="sNdText">\r\n      <xsl:value-of select="normalize-space($ndCur/*[2])"/>\r\n    </xsl:variable>\r\n\r\n    <xsl:choose>\r\n      <!-- Is this an omml function -->\r\n      <xsl:when test="count($ndCur/*)=3\r\n\t\t\t\t\t\t\t\t      and $ndCur/self::*[self::mml:mrow]\r\n                      and $ndCur/*[2][self::mml:mo]\r\n                      and $sNdText='&#x02061;'">1</xsl:when>\r\n      <xsl:otherwise>0</xsl:otherwise>\r\n    </xsl:choose>\r\n  </xsl:template>\r\n\r\n\r\n  <!-- Given the node of the linear fraction's parent mrow, \r\n       make a linear fraction -->\r\n  <xsl:template name="MakeLinearFraction">\r\n    <xsl:param name="ndCur" select="." />\r\n    <xsl:element name="m:f">\r\n      <xsl:element name="m:fPr">\r\n        <xsl:element name="m:type">\r\n          <xsl:attribute name="m:val">lin</xsl:attribute>\r\n        </xsl:element>\r\n      </xsl:element>\r\n      <xsl:element name="m:num">\r\n        <xsl:call-template name="CreateArgProp" />\r\n        <xsl:apply-templates select="$ndCur/*[1]" />\r\n      </xsl:element>\r\n      <xsl:element name="m:den">\r\n        <xsl:call-template name="CreateArgProp" />\r\n        <xsl:apply-templates select="$ndCur/*[3]" />\r\n      </xsl:element>\r\n    </xsl:element>\r\n  </xsl:template>\r\n\r\n\r\n  <!-- Given the node of the function's parent mrow, \r\n       make an omml function -->\r\n  <xsl:template name="WriteFunc">\r\n    <xsl:param name="ndCur" select="." />\r\n\r\n    <xsl:element name="m:func">\r\n      <xsl:element name="m:fName">\r\n        <xsl:apply-templates select="$ndCur/child::*[1]" />\r\n      </xsl:element>\r\n      <xsl:element name="m:e">\r\n        <xsl:apply-templates select="$ndCur/child::*[3]" />\r\n      </xsl:element>\r\n    </xsl:element>\r\n  </xsl:template>\r\n\r\n\r\n  <!-- MathML doesn't have the concept of nAry structures.  The best approximation\r\n       to these is to have some under/over or sub/sup followed by an mrow or mstyle.\r\n       \r\n       In the case that we've come across some under/over or sub/sup that contains an \r\n       nAry operator, this function handles the following sibling to the nAry structure.\r\n       \r\n       If the following sibling is:\r\n       \r\n          mml:mstyle, then apply templates to the children of this mml:mstyle\r\n          \r\n          mml:mrow, determine if this mrow is a linear fraction \r\n          (see comments for FlinearFrac template).\r\n              If so, make an Omml linear fraction.\r\n              If not, apply templates as was done for mml:mstyle.\r\n       \r\n       -->\r\n  <xsl:template name="NaryHandleMrowMstyle">\r\n    <xsl:param name="ndCur" select="." />\r\n    <!-- if the next sibling is an mrow, pull it in by \r\n\t\t\t\t\t\t\tdoing whatever we would have done to its children. \r\n\t\t\t\t\t\t\tThe mrow itself will be skipped, see template above. -->\r\n    <xsl:choose>\r\n      <xsl:when test="$ndCur[self::mml:mrow]">\r\n        <!-- Check for linear fraction -->\r\n        <xsl:variable name="fLinearFrac">\r\n          <xsl:call-template name="FLinearFrac">\r\n            <xsl:with-param name="ndCur" select="$ndCur" />\r\n          </xsl:call-template>\r\n        </xsl:variable>\r\n        <xsl:choose>\r\n          <xsl:when test="$fLinearFrac=1">\r\n            <xsl:call-template name="MakeLinearFraction">\r\n              <xsl:with-param name="ndCur" select="$ndCur" />\r\n            </xsl:call-template>\r\n          </xsl:when>\r\n          <xsl:otherwise>\r\n            <xsl:variable name="fFunc">\r\n              <xsl:call-template name="FIsFunc">\r\n                <xsl:with-param name="ndCur" select="." />\r\n              </xsl:call-template>\r\n            </xsl:variable>\r\n            <xsl:choose>\r\n              <xsl:when test="$fFunc=1">\r\n                <xsl:call-template name="WriteFunc">\r\n                  <xsl:with-param name="ndCur" select="." />\r\n                </xsl:call-template>\r\n              </xsl:when>\r\n              <xsl:otherwise>\r\n                <xsl:apply-templates select="$ndCur/*" />\r\n              </xsl:otherwise>\r\n            </xsl:choose>\r\n          </xsl:otherwise>\r\n        </xsl:choose>\r\n      </xsl:when>\r\n      <xsl:when test="$ndCur[self::mml:mstyle]">\r\n        <xsl:apply-templates select="$ndCur/*" />\r\n      </xsl:when>\r\n    </xsl:choose>\r\n  </xsl:template>\r\n\r\n\r\n  <!-- MathML munder/mover can represent several Omml constructs \r\n       (m:bar, m:limLow, m:limUpp, m:acc, m:groupChr, etc.).  The following \r\n       templates (FIsBar, FIsAcc, and FIsGroupChr) are used to determine \r\n\t\t\t which of these Omml constructs an munder/mover should be translated into. -->\r\n\r\n  <!-- Note:  ndCur should only be an munder/mover MathML element.\r\n  \r\n       ndCur should be interpretted as an m:bar if\r\n          1)  its respective accent attribute is not true\r\n          2)  its second child is an mml:mo\r\n          3)  the character of the mml:mo is the correct under/over bar. -->\r\n  <xsl:template name="FIsBar">\r\n    <xsl:param name="ndCur" />\r\n    <xsl:variable name="fUnder">\r\n      <xsl:choose>\r\n        <xsl:when test="$ndCur[self::mml:munder]">1</xsl:when>\r\n        <xsl:otherwise>0</xsl:otherwise>\r\n      </xsl:choose>\r\n    </xsl:variable>\r\n    <xsl:variable name="sLowerCaseAccent">\r\n      <xsl:choose>\r\n        <xsl:when test="$fUnder=1">\r\n          <xsl:choose>\r\n            <xsl:when test="$ndCur/@accentunder">\r\n              <xsl:value-of select="translate($ndCur/@accentunder, $StrUCAlphabet, $StrLCAlphabet)"/>\r\n            </xsl:when>\r\n            <xsl:otherwise>\r\n              <xsl:value-of select="translate($ndCur/@mml:accentunder, $StrUCAlphabet, $StrLCAlphabet)"/>\r\n            </xsl:otherwise>\r\n          </xsl:choose>\r\n        </xsl:when>\r\n        <xsl:otherwise>\r\n          <xsl:choose>\r\n            <xsl:when test="$ndCur/@accent">\r\n              <xsl:value-of select="translate($ndCur/@accent, $StrUCAlphabet, $StrLCAlphabet)"/>\r\n            </xsl:when>\r\n            <xsl:otherwise>\r\n              <xsl:value-of select="translate($ndCur/@mml:accent, $StrUCAlphabet, $StrLCAlphabet)"/>\r\n            </xsl:otherwise>\r\n          </xsl:choose>\r\n        </xsl:otherwise>\r\n      </xsl:choose>\r\n    </xsl:variable>\r\n    <xsl:variable name="fAccent">\r\n      <xsl:choose>\r\n        <xsl:when test="$sLowerCaseAccent='true'">1</xsl:when>\r\n        <xsl:otherwise>0</xsl:otherwise>\r\n      </xsl:choose>\r\n    </xsl:variable>\r\n\r\n    <xsl:choose>\r\n      <!-- The script is unaccented and the second child is an mo -->\r\n      <xsl:when test="$fAccent = 0 \r\n                      and $ndCur/child::*[2]/self::mml:mo">\r\n        <xsl:variable name="sOperator">\r\n          <xsl:value-of select="$ndCur/child::*[2]" />\r\n        </xsl:variable>\r\n        <xsl:choose>\r\n          <!-- Should we write an underbar? -->\r\n          <xsl:when test="$fUnder = 1">\r\n            <xsl:choose>\r\n              <xsl:when test="$sOperator = '&#x0332;' or $sOperator = '&#x005F;'">1</xsl:when>\r\n              <xsl:otherwise>0</xsl:otherwise>\r\n            </xsl:choose>\r\n          </xsl:when>\r\n          <!-- Should we write an overbar? -->\r\n          <xsl:otherwise>\r\n            <xsl:choose>\r\n              <xsl:when test="$sOperator = '&#x0305;' or $sOperator = '&#x00AF;'">1</xsl:when>\r\n              <xsl:otherwise>0</xsl:otherwise>\r\n            </xsl:choose>\r\n          </xsl:otherwise>\r\n        </xsl:choose>\r\n      </xsl:when>\r\n      <xsl:otherwise>0</xsl:otherwise>\r\n    </xsl:choose>\r\n  </xsl:template>\r\n\r\n  <!-- Note:  ndCur should only be an mover MathML element.\r\n  \r\n       ndCur should be interpretted as an m:acc if\r\n          1)  its accent attribute is true\r\n          2)  its second child is an mml:mo\r\n          3)  there is only zero or one character in the mml:mo -->\r\n  <xsl:template name="FIsAcc">\r\n    <xsl:param name="ndCur" select="." />\r\n\r\n    <xsl:variable name="sLowerCaseAccent">\r\n      <xsl:choose>\r\n        <xsl:when test="$ndCur/@accent">\r\n          <xsl:value-of select="translate($ndCur/@accent, $StrUCAlphabet, $StrLCAlphabet)"/>\r\n        </xsl:when>\r\n        <xsl:otherwise>\r\n          <xsl:value-of select="translate($ndCur/@mml:accent, $StrUCAlphabet, $StrLCAlphabet)"/>\r\n        </xsl:otherwise>\r\n      </xsl:choose>\r\n    </xsl:variable>\r\n    <xsl:variable name="sLowerCaseMoAccent">\r\n      <xsl:choose>\r\n        <xsl:when test="$ndCur/child::*[2] = mml:mo and $ndCur/child::*[2]/@accent">\r\n          <xsl:value-of select="translate($ndCur/child::*[2]/@accent, $StrUCAlphabet, $StrLCAlphabet)"/>\r\n        </xsl:when>\r\n        <xsl:when test="$ndCur/child::*[2] = mml:mo and $ndCur/child::*[2]/@mml:accent">\r\n          <xsl:value-of select="translate($ndCur/child::*[2]/@mml:accent, $StrUCAlphabet, $StrLCAlphabet)"/>\r\n        </xsl:when>\r\n      </xsl:choose>\r\n    </xsl:variable>\r\n    <xsl:variable name="fAccent">\r\n      <xsl:choose>\r\n        <xsl:when test="$sLowerCaseMoAccent='true' or ($sLowerCaseMoAccent='' and $sLowerCaseAccent='true')">1</xsl:when>\r\n        <xsl:otherwise>0</xsl:otherwise>\r\n      </xsl:choose>\r\n    </xsl:variable>\r\n\r\n    <xsl:choose>\r\n      <!-- The script is accented and the second child is an mo -->\r\n      <xsl:when test="$fAccent = 1 \r\n                      and $ndCur/child::*[2] = mml:mo">\r\n        <xsl:variable name="sOperator">\r\n          <xsl:value-of select="$ndCur/child::*[2]" />\r\n        </xsl:variable>\r\n        <xsl:choose>\r\n          <!-- There is only one operator, this is a valid Omml accent! -->\r\n          <xsl:when test="string-length($sOperator) &lt;= 1">1</xsl:when>\r\n          <!-- More than one accented operator.  This isn't a valid\r\n               omml accent -->\r\n          <xsl:otherwise>0</xsl:otherwise>\r\n        </xsl:choose>\r\n      </xsl:when>\r\n      <!-- Not accented, not an operator, or both, but in any case, this is\r\n           not an Omml accent. -->\r\n      <xsl:otherwise>0</xsl:otherwise>\r\n    </xsl:choose>\r\n  </xsl:template>\r\n\r\n\r\n  <!-- Is ndCur a groupChr? \r\n\t\t\t ndCur is a groupChr if:\r\n\t\t\t \r\n\t\t\t\t 1.  The accent is false (note:  accent attribute \r\n\t\t\t\t\t\t for munder is accentunder). \r\n\t\t\t\t 2.  ndCur is an munder or mover.\r\n\t\t\t\t 3.  ndCur has two children\r\n\t\t\t\t 4.  Of these two children, one is an mml:mo and the other is an mml:mrow\r\n\t\t\t\t 5.  The number of characters in the mml:mo is 1.\r\n\t\t\t \r\n\t\t\t If all of the above are true, then return 1, else return 0.\r\n\t-->\r\n  <xsl:template name="FIsGroupChr">\r\n    <xsl:param name="ndCur" select="." />\r\n    <xsl:variable name="fUnder">\r\n      <xsl:choose>\r\n        <xsl:when test="$ndCur[self::mml:munder]">1</xsl:when>\r\n        <xsl:otherwise>0</xsl:otherwise>\r\n      </xsl:choose>\r\n    </xsl:variable>\r\n    <xsl:variable name="sLowerCaseAccent">\r\n      <xsl:choose>\r\n        <xsl:when test="$fUnder=1">\r\n          <xsl:choose>\r\n            <xsl:when test="$ndCur/@accentunder">\r\n              <xsl:value-of select="translate($ndCur/@accentunder, $StrUCAlphabet, $StrLCAlphabet)"/>\r\n            </xsl:when>\r\n            <xsl:otherwise>\r\n              <xsl:value-of select="translate($ndCur/@mml:accentunder, $StrUCAlphabet, $StrLCAlphabet)"/>\r\n            </xsl:otherwise>\r\n          </xsl:choose>\r\n        </xsl:when>\r\n        <xsl:otherwise>\r\n          <xsl:choose>\r\n            <xsl:when test="$ndCur/@accent">\r\n              <xsl:value-of select="translate($ndCur/@accent, $StrUCAlphabet, $StrLCAlphabet)"/>\r\n            </xsl:when>\r\n            <xsl:otherwise>\r\n              <xsl:value-of select="translate($ndCur/@mml:accent, $StrUCAlphabet, $StrLCAlphabet)"/>\r\n            </xsl:otherwise>\r\n          </xsl:choose>\r\n        </xsl:otherwise>\r\n      </xsl:choose>\r\n    </xsl:variable>\r\n\r\n    <xsl:variable name="fAccentFalse">\r\n      <xsl:choose>\r\n        <xsl:when test="$sLowerCaseAccent='false'">1</xsl:when>\r\n        <xsl:otherwise>0</xsl:otherwise>\r\n      </xsl:choose>\r\n    </xsl:variable>\r\n\r\n    <xsl:choose>\r\n      <xsl:when test="$fAccentFalse=1\r\n                      and $ndCur[self::mml:munder or self::mml:mover] \r\n                      and count($ndCur/child::*)=2 \r\n                      and (($ndCur/child::*[1][self::mml:mrow] and $ndCur/child::*[2][self::mml:mo]) \r\n                            or ($ndCur/child::*[1][self::mml:mo] and $ndCur/child::*[2][self::mml:mrow]))">\r\n        <xsl:variable name="sOperator">\r\n          <xsl:value-of select="$ndCur/child::mml:mo" />\r\n        </xsl:variable>\r\n        <xsl:choose>\r\n          <xsl:when test="string-length($sOperator) &lt;= 1">1</xsl:when>\r\n          <xsl:otherwise>0</xsl:otherwise>\r\n        </xsl:choose>\r\n      </xsl:when>\r\n\r\n      <xsl:otherwise>0</xsl:otherwise>\r\n    </xsl:choose>\r\n  </xsl:template>\r\n\r\n\r\n  <!-- %%Template: match munder\r\n\t-->\r\n  <xsl:template match="mml:munder">\r\n    <xsl:variable name="fNary">\r\n      <xsl:call-template name="isNary">\r\n        <xsl:with-param name="ndCur" select="child::*[1]" />\r\n      </xsl:call-template>\r\n    </xsl:variable>\r\n    <xsl:choose>\r\n      <xsl:when test="$fNary='true'">\r\n        <m:nary>\r\n          <xsl:call-template name="CreateNaryProp">\r\n            <xsl:with-param name="chr">\r\n              <xsl:value-of select="normalize-space(child::*[1])" />\r\n            </xsl:with-param>\r\n            <xsl:with-param name="sMathmlType" select="'munder'" />\r\n          </xsl:call-template>\r\n          <m:sub>\r\n            <xsl:call-template name="CreateArgProp" />\r\n            <xsl:apply-templates select="child::*[2]" />\r\n          </m:sub>\r\n          <m:sup>\r\n            <xsl:call-template name="CreateArgProp" />\r\n          </m:sup>\r\n          <m:e>\r\n            <xsl:call-template name="CreateArgProp" />\r\n            <xsl:call-template name="NaryHandleMrowMstyle">\r\n              <xsl:with-param name="ndCur" select="following-sibling::*[1]" />\r\n            </xsl:call-template>\r\n          </m:e>\r\n        </m:nary>\r\n      </xsl:when>\r\n      <xsl:otherwise>\r\n        <!-- Should this munder be interpreted as an OMML m:bar? -->\r\n        <xsl:variable name="fIsBar">\r\n          <xsl:call-template name="FIsBar">\r\n            <xsl:with-param name="ndCur" select="." />\r\n          </xsl:call-template>\r\n        </xsl:variable>\r\n        <xsl:choose>\r\n          <xsl:when test="$fIsBar=1">\r\n            <m:bar>\r\n              <m:barPr>\r\n                <m:pos m:val="bot" />\r\n              </m:barPr>\r\n              <m:e>\r\n                <xsl:call-template name="CreateArgProp" />\r\n                <xsl:apply-templates select="child::*[1]" />\r\n              </m:e>\r\n            </m:bar>\r\n          </xsl:when>\r\n          <xsl:otherwise>\r\n            <!-- It isn't an integral or underbar, is this a groupChr? -->\r\n            <xsl:variable name="fGroupChr">\r\n              <xsl:call-template name="FIsGroupChr">\r\n                <xsl:with-param name="ndCur" select="." />\r\n              </xsl:call-template>\r\n            </xsl:variable>\r\n            <xsl:choose>\r\n              <xsl:when test="$fGroupChr=1">\r\n                <xsl:element name="m:groupChr">\r\n                  <xsl:call-template name="CreateGroupChrPr">\r\n                    <xsl:with-param name="chr">\r\n                      <xsl:value-of select="mml:mo" />\r\n                    </xsl:with-param>\r\n                    <xsl:with-param name="pos">\r\n                      <xsl:choose>\r\n                        <xsl:when test="child::*[1][self::mml:mrow]">bot</xsl:when>\r\n                        <xsl:otherwise>top</xsl:otherwise>\r\n                      </xsl:choose>\r\n                    </xsl:with-param>\r\n                    <xsl:with-param name="vertJc">top</xsl:with-param>\r\n                  </xsl:call-template>\r\n                  <xsl:element name="m:e">\r\n                    <xsl:apply-templates select="mml:mrow" />\r\n                  </xsl:element>\r\n                </xsl:element>\r\n              </xsl:when>\r\n              <xsl:otherwise>\r\n                <!-- Generic munder -->\r\n                <xsl:element name="m:limLow">\r\n                  <xsl:element name="m:e">\r\n                    <xsl:call-template name="CreateArgProp" />\r\n                    <xsl:apply-templates select="child::*[1]" />\r\n                  </xsl:element>\r\n                  <xsl:element name="m:lim">\r\n                    <xsl:call-template name="CreateArgProp" />\r\n                    <xsl:apply-templates select="child::*[2]" />\r\n                  </xsl:element>\r\n                </xsl:element>\r\n              </xsl:otherwise>\r\n            </xsl:choose>\r\n          </xsl:otherwise>\r\n        </xsl:choose>\r\n      </xsl:otherwise>\r\n    </xsl:choose>\r\n  </xsl:template>\r\n\r\n\r\n  <!-- Given the values for chr, pos, and vertJc, create an omml\r\n\t     groupChr's groupChrPr -->\r\n  <xsl:template name="CreateGroupChrPr">\r\n    <xsl:param name="chr">&#x23df;</xsl:param>\r\n    <xsl:param name="pos" select="bot" />\r\n    <xsl:param name="vertJc" select="top" />\r\n    <xsl:element name="m:groupChrPr">\r\n      <xsl:element name="m:chr">\r\n        <xsl:attribute name="m:val">\r\n          <xsl:value-of select="$chr"/>\r\n        </xsl:attribute>\r\n      </xsl:element>\r\n      <xsl:element name="m:pos">\r\n        <xsl:attribute name="m:val">\r\n          <xsl:value-of select="$pos"/>\r\n        </xsl:attribute>\r\n      </xsl:element>\r\n      <xsl:element name="m:vertJc">\r\n        <xsl:attribute name="m:val">\r\n          <xsl:value-of select="$vertJc"/>\r\n        </xsl:attribute>\r\n      </xsl:element>\r\n    </xsl:element>\r\n  </xsl:template>\r\n\r\n\r\n  <!--\r\n      Convert a non-combining character into its upper combining\r\n      couterpart.\r\n      \r\n      { Non-combining, Upper-combining }\r\n      {U+02D8, U+0306}, // BREVE\r\n      {U+00B8, U+0312}, // CEDILLA\r\n      {U+0060, U+0300}, // GRAVE ACCENT\r\n      {U+002D, U+0305}, // HYPHEN-MINUS/OVERLINE\r\n      {U+2212, U+0305}, // MINUS SIGN/OVERLINE\r\n      {U+002E, U+0305}, // FULL STOP/DOT ABOVE\r\n      {U+02D9, U+0307}, // DOT ABOVE\r\n      {U+02DD, U+030B}, // DOUBLE ACUTE ACCENT\r\n      {U+00B4, U+0301}, // ACUTE ACCENT\r\n      {U+007E, U+0303}, // TILDE\r\n      {U+02DC, U+0303}, // SMALL TILDE\r\n      {U+00A8, U+0308}, // DIAERESIS\r\n      {U+02C7, U+030C}, // CARON\r\n      {U+005E, U+0302}, // CIRCUMFLEX ACCENT\r\n      {U+00AF, U+0305}, // MACRON\r\n      {U+005F, ::::::}, // LOW LINE\r\n      {U+2192, U+20D7}, // RIGHTWARDS ARROW\r\n      {U+27F6, U+20D7}, // LONG RIGHTWARDS ARROW\r\n      {U+2190, U+20D6}, // LEFT ARROW\r\n  -->\r\n  <xsl:template name="ToUpperCombining">\r\n    <xsl:param name="ch" />\r\n    <xsl:choose>\r\n      <!-- BREVE -->\r\n      <xsl:when test="$ch='&#x02D8;'">&#x0306;</xsl:when>\r\n      <!-- CEDILLA -->\r\n      <xsl:when test="$ch='&#x00B8;'">&#x0312;</xsl:when>\r\n      <!-- GRAVE ACCENT -->\r\n      <xsl:when test="$ch='&#x0060;'">&#x0300;</xsl:when>\r\n      <!-- HYPHEN-MINUS/OVERLINE -->\r\n      <xsl:when test="$ch='&#x002D;'">&#x0305;</xsl:when>\r\n      <!-- MINUS SIGN/OVERLINE -->\r\n      <xsl:when test="$ch='&#x2212;'">&#x0305;</xsl:when>\r\n      <!-- FULL STOP/DOT ABOVE -->\r\n      <xsl:when test="$ch='&#x002E;'">&#x0307;</xsl:when>\r\n      <!-- DOT ABOVE -->\r\n      <xsl:when test="$ch='&#x02D9;'">&#x0307;</xsl:when>\r\n      <!-- DOUBLE ACUTE ACCENT -->\r\n      <xsl:when test="$ch='&#x02DD;'">&#x030B;</xsl:when>\r\n      <!-- ACUTE ACCENT -->\r\n      <xsl:when test="$ch='&#x00B4;'">&#x0301;</xsl:when>\r\n      <!-- TILDE -->\r\n      <xsl:when test="$ch='&#x007E;'">&#x0303;</xsl:when>\r\n      <!-- SMALL TILDE -->\r\n      <xsl:when test="$ch='&#x02DC;'">&#x0303;</xsl:when>\r\n      <!-- DIAERESIS -->\r\n      <xsl:when test="$ch='&#x00A8;'">&#x0308;</xsl:when>\r\n      <!-- CARON -->\r\n      <xsl:when test="$ch='&#x02C7;'">&#x030C;</xsl:when>\r\n      <!-- CIRCUMFLEX ACCENT -->\r\n      <xsl:when test="$ch='&#x005E;'">&#x0302;</xsl:when>\r\n      <!-- MACRON -->\r\n      <xsl:when test="$ch='&#x00AF;'">&#x0305;</xsl:when>\r\n      \r\n      <!-- LOW LINE -->\r\n      \r\n      <!-- RIGHTWARDS ARROW -->\r\n      <xsl:when test="$ch='&#x2192;'">&#x20D7;</xsl:when>\r\n      <!-- LONG RIGHTWARDS ARROW -->\r\n      <xsl:when test="$ch='&#x27F6;'">&#x20D7;</xsl:when>\r\n      <!-- LEFT ARROW -->\r\n      <xsl:when test="$ch='&#x2190;'">&#x20D6;</xsl:when>\r\n      <xsl:otherwise>\r\n        <xsl:value-of select="$ch"/>\r\n      </xsl:otherwise>\r\n    </xsl:choose>\r\n  </xsl:template>\r\n\r\n\r\n  <!-- %%Template: match mover\r\n\t-->\r\n  <xsl:template match="mml:mover">\r\n    <xsl:variable name="fNary">\r\n      <xsl:call-template name="isNary">\r\n        <xsl:with-param name="ndCur" select="child::*[1]" />\r\n      </xsl:call-template>\r\n    </xsl:variable>\r\n    <xsl:choose>\r\n      <xsl:when test="$fNary='true'">\r\n        <m:nary>\r\n          <xsl:call-template name="CreateNaryProp">\r\n            <xsl:with-param name="chr">\r\n              <xsl:value-of select="normalize-space(child::*[1])" />\r\n            </xsl:with-param>\r\n            <xsl:with-param name="sMathmlType" select="'mover'" />\r\n          </xsl:call-template>\r\n          <m:sub>\r\n            <xsl:call-template name="CreateArgProp" />\r\n          </m:sub>\r\n          <m:sup>\r\n            <xsl:call-template name="CreateArgProp" />\r\n            <xsl:apply-templates select="child::*[2]" />\r\n          </m:sup>\r\n          <m:e>\r\n            <xsl:call-template name="CreateArgProp" />\r\n            <xsl:call-template name="NaryHandleMrowMstyle">\r\n              <xsl:with-param name="ndCur" select="following-sibling::*[1]" />\r\n            </xsl:call-template>\r\n          </m:e>\r\n        </m:nary>\r\n      </xsl:when>\r\n      <xsl:otherwise>\r\n        <!-- Should this munder be interpreted as an OMML m:bar or m:acc? -->\r\n\r\n        <!-- Check to see if this is an m:bar -->\r\n        <xsl:variable name="fIsBar">\r\n          <xsl:call-template name="FIsBar">\r\n            <xsl:with-param name="ndCur" select="." />\r\n          </xsl:call-template>\r\n        </xsl:variable>\r\n        <xsl:choose>\r\n          <xsl:when test="$fIsBar = 1">\r\n            <m:bar>\r\n              <m:barPr>\r\n                <m:pos m:val="top" />\r\n              </m:barPr>\r\n              <m:e>\r\n                <xsl:call-template name="CreateArgProp" />\r\n                <xsl:apply-templates select="child::*[1]" />\r\n              </m:e>\r\n            </m:bar>\r\n          </xsl:when>\r\n          <xsl:otherwise>\r\n            <!-- Not an m:bar, should it be an m:acc? -->\r\n            <xsl:variable name="fIsAcc">\r\n              <xsl:call-template name="FIsAcc">\r\n                <xsl:with-param name="ndCur" select="." />\r\n              </xsl:call-template>\r\n            </xsl:variable>\r\n            <xsl:choose>\r\n              <xsl:when test="$fIsAcc=1">\r\n                <m:acc>\r\n                  <m:accPr>\r\n                    <m:chr>\r\n                      <xsl:variable name="ch">\r\n                        <xsl:value-of select="child::*[2]" />\r\n                      </xsl:variable>\r\n                      <xsl:variable name="chComb">\r\n                        <xsl:call-template name="ToUpperCombining">\r\n                          <xsl:with-param name="ch" select="$ch" />\r\n                        </xsl:call-template>\r\n                      </xsl:variable>\r\n                      <xsl:attribute name="m:val">\r\n                        <xsl:value-of select="$chComb" />\r\n                      </xsl:attribute>\r\n                    </m:chr>\r\n                  </m:accPr>\r\n                  <m:e>\r\n                    <xsl:call-template name="CreateArgProp" />\r\n                    <xsl:apply-templates select="child::*[1]" />\r\n                  </m:e>\r\n                </m:acc>\r\n              </xsl:when>\r\n              <xsl:otherwise>\r\n                <!-- This isn't an integral, overbar or accent, \r\n\t\t\t\t\t\t\t\t     could it be a groupChr? -->\r\n                <xsl:variable name="fGroupChr">\r\n                  <xsl:call-template name="FIsGroupChr">\r\n                    <xsl:with-param name="ndCur" select="." />\r\n                  </xsl:call-template>\r\n                </xsl:variable>\r\n                <xsl:choose>\r\n                  <xsl:when test="$fGroupChr=1">\r\n                    <xsl:element name="m:groupChr">\r\n                      <xsl:call-template name="CreateGroupChrPr">\r\n                        <xsl:with-param name="chr">\r\n                          <xsl:value-of select="mml:mo" />\r\n                        </xsl:with-param>\r\n                        <xsl:with-param name="pos">\r\n                          <xsl:choose>\r\n                            <xsl:when test="child::*[1][self::mml:mrow]">top</xsl:when>\r\n                            <xsl:otherwise>bot</xsl:otherwise>\r\n                          </xsl:choose>\r\n                        </xsl:with-param>\r\n                        <xsl:with-param name="vertJc">bot</xsl:with-param>\r\n                      </xsl:call-template>\r\n                      <xsl:element name="m:e">\r\n                        <xsl:apply-templates select="mml:mrow" />\r\n                      </xsl:element>\r\n                    </xsl:element>\r\n                  </xsl:when>\r\n                  <xsl:otherwise>\r\n                    <!-- Generic mover -->\r\n                    <xsl:element name="m:limUpp">\r\n                      <xsl:element name="m:e">\r\n                        <xsl:call-template name="CreateArgProp" />\r\n                        <xsl:apply-templates select="child::*[1]" />\r\n                      </xsl:element>\r\n                      <xsl:element name="m:lim">\r\n                        <xsl:call-template name="CreateArgProp" />\r\n                        <xsl:apply-templates select="child::*[2]" />\r\n                      </xsl:element>\r\n                    </xsl:element>\r\n                  </xsl:otherwise>\r\n                </xsl:choose>\r\n              </xsl:otherwise>\r\n            </xsl:choose>\r\n          </xsl:otherwise>\r\n        </xsl:choose>\r\n      </xsl:otherwise>\r\n    </xsl:choose>\r\n  </xsl:template>\r\n\r\n\r\n  <!-- %%Template: match munderover\r\n\t-->\r\n  <xsl:template match="mml:munderover">\r\n    <xsl:variable name="fNary">\r\n      <xsl:call-template name="isNary">\r\n        <xsl:with-param name="ndCur" select="child::*[1]" />\r\n      </xsl:call-template>\r\n    </xsl:variable>\r\n    <xsl:choose>\r\n      <xsl:when test="$fNary='true'">\r\n        <m:nary>\r\n          <xsl:call-template name="CreateNaryProp">\r\n            <xsl:with-param name="chr">\r\n              <xsl:value-of select="normalize-space(child::*[1])" />\r\n            </xsl:with-param>\r\n            <xsl:with-param name="sMathmlType" select="'munderover'" />\r\n          </xsl:call-template>\r\n          <m:sub>\r\n            <xsl:call-template name="CreateArgProp" />\r\n            <xsl:apply-templates select="child::*[2]" />\r\n          </m:sub>\r\n          <m:sup>\r\n            <xsl:call-template name="CreateArgProp" />\r\n            <xsl:apply-templates select="child::*[3]" />\r\n          </m:sup>\r\n          <m:e>\r\n            <xsl:call-template name="CreateArgProp" />\r\n            <xsl:call-template name="NaryHandleMrowMstyle">\r\n              <xsl:with-param name="ndCur" select="following-sibling::*[1]" />\r\n            </xsl:call-template>\r\n          </m:e>\r\n        </m:nary>\r\n      </xsl:when>\r\n      <xsl:otherwise>\r\n        <xsl:element name="m:limUpp">\r\n          <xsl:element name="m:e">\r\n            <xsl:call-template name="CreateArgProp" />\r\n            <xsl:element name="m:limLow">\r\n              <xsl:element name="m:e">\r\n                <xsl:call-template name="CreateArgProp" />\r\n                <xsl:apply-templates select="child::*[1]" />\r\n              </xsl:element>\r\n              <xsl:element name="m:lim">\r\n                <xsl:call-template name="CreateArgProp" />\r\n                <xsl:apply-templates select="child::*[2]" />\r\n              </xsl:element>\r\n            </xsl:element>\r\n          </xsl:element>\r\n          <xsl:element name="m:lim">\r\n            <xsl:call-template name="CreateArgProp" />\r\n            <xsl:apply-templates select="child::*[3]" />\r\n          </xsl:element>\r\n        </xsl:element>\r\n      </xsl:otherwise>\r\n    </xsl:choose>\r\n  </xsl:template>\r\n\r\n  <!-- %%Template: match mfenced -->\r\n  <xsl:template match="mml:mfenced">\r\n    <m:d>\r\n      <xsl:call-template name="CreateDelimProp">\r\n        <xsl:with-param name="fChOpenValid">\r\n          <xsl:choose>\r\n            <xsl:when test="@open">\r\n              <xsl:value-of select="1"/>\r\n            </xsl:when>\r\n            <xsl:when test="@mml:open">\r\n              <xsl:value-of select="1"/>\r\n            </xsl:when>\r\n            <xsl:otherwise>\r\n              <xsl:value-of select="0"/>\r\n            </xsl:otherwise>\r\n          </xsl:choose>\r\n        </xsl:with-param>\r\n        <xsl:with-param name="chOpen">\r\n          <xsl:choose>\r\n            <xsl:when test="@open">\r\n              <xsl:value-of select="@open"/>\r\n            </xsl:when>\r\n            <xsl:otherwise>\r\n              <xsl:value-of select="@mml:open"/>\r\n            </xsl:otherwise>\r\n          </xsl:choose>\r\n        </xsl:with-param>\r\n        <xsl:with-param name="fChSeparatorsValid">\r\n          <xsl:choose>\r\n            <xsl:when test="@separators">\r\n              <xsl:value-of select="1"/>\r\n            </xsl:when>\r\n            <xsl:when test="@mml:separators">\r\n              <xsl:value-of select="1"/>\r\n            </xsl:when>\r\n            <xsl:otherwise>\r\n              <xsl:value-of select="0"/>\r\n            </xsl:otherwise>\r\n          </xsl:choose>\r\n        </xsl:with-param>\r\n        <xsl:with-param name="chSeparators">\r\n          <xsl:choose>\r\n            <xsl:when test="@separators">\r\n              <xsl:value-of select="@separators"/>\r\n            </xsl:when>\r\n            <xsl:otherwise>\r\n              <xsl:value-of select="@mml:separators"/>\r\n            </xsl:otherwise>\r\n          </xsl:choose>\r\n        </xsl:with-param>\r\n        <xsl:with-param name="fChCloseValid">\r\n          <xsl:choose>\r\n            <xsl:when test="@close">\r\n              <xsl:value-of select="1"/>\r\n            </xsl:when>\r\n            <xsl:when test="@mml:close">\r\n              <xsl:value-of select="1"/>\r\n            </xsl:when>\r\n            <xsl:otherwise>\r\n              <xsl:value-of select="0"/>\r\n            </xsl:otherwise>\r\n          </xsl:choose>\r\n        </xsl:with-param>\r\n        <xsl:with-param name="chClose">\r\n          <xsl:choose>\r\n            <xsl:when test="@close">\r\n              <xsl:value-of select="@close"/>\r\n            </xsl:when>\r\n            <xsl:otherwise>\r\n              <xsl:value-of select="@mml:close"/>\r\n            </xsl:otherwise>\r\n          </xsl:choose>\r\n        </xsl:with-param>\r\n      </xsl:call-template>\r\n      <xsl:for-each select="*">\r\n        <m:e>\r\n          <xsl:call-template name="CreateArgProp" />\r\n          <xsl:apply-templates select="."/>\r\n        </m:e>\r\n      </xsl:for-each>\r\n    </m:d>\r\n  </xsl:template>\r\n\r\n  <!-- %%Template: CreateDelimProp\r\n\t\r\n\t\tGiven the characters to use as open, close and separators for \r\n\t\tthe delim object, create the m:dPr (delim properties). \t\t\r\n\t\t\r\n\t\tMathML can have any number of separators in an mfenced object, but \r\n\t\tOMML can only represent one separator for each d (delim) object.\r\n\t\tSo, we pick the first separator specified. \t\t\r\n\t-->\r\n  <xsl:template name="CreateDelimProp">\r\n    <xsl:param name="fChOpenValid" />\r\n    <xsl:param name="chOpen" />\r\n    <xsl:param name="fChSeparatorsValid" />\r\n    <xsl:param name="chSeparators" />\r\n    <xsl:param name="fChCloseValid" />\r\n    <xsl:param name="chClose" />\r\n    <xsl:variable name="chSep" select="substring($chSeparators, 1, 1)" />\r\n\r\n    <!-- do we need a dPr at all? If everything's at its default value, then \r\n\t\t\tdon't bother at all -->\r\n    <xsl:if test="($fChOpenValid=1 and not($chOpen = '(')) or\r\n\t\t\t\t\t\t  ($fChCloseValid=1 and not($chClose = ')')) or \r\n\t\t\t\t\t\t  not($chSep = '|')">\r\n      <m:dPr>\r\n        <!-- the default for MathML and OMML is '('. -->\r\n        <xsl:if test="$fChOpenValid=1 and not($chOpen = '(')">\r\n          <m:begChr>\r\n            <xsl:attribute name="m:val">\r\n              <xsl:value-of select="$chOpen" />\r\n            </xsl:attribute>\r\n          </m:begChr>\r\n        </xsl:if>\r\n\r\n        <!-- the default for MathML is ',' and for OMML is '|' -->\r\n\r\n        <xsl:choose>\r\n          <!-- matches OMML's default, don't bother to write anything out -->\r\n          <xsl:when test="$chSep = '|'" />\r\n\r\n          <!-- Not specified, use MathML's default. We test against \r\n\t\t\t\t\tthe existence of the actual attribute, not the substring -->\r\n          <xsl:when test="$fChSeparatorsValid=0">\r\n            <m:sepChr m:val=',' />\r\n          </xsl:when>\r\n\r\n          <xsl:otherwise>\r\n            <m:sepChr>\r\n              <xsl:attribute name="m:val">\r\n                <xsl:value-of select="$chSep" />\r\n              </xsl:attribute>\r\n            </m:sepChr>\r\n          </xsl:otherwise>\r\n        </xsl:choose>\r\n\r\n        <!-- the default for MathML and OMML is ')'. -->\r\n        <xsl:if test="$fChCloseValid=1 and not($chClose = ')')">\r\n          <m:endChr>\r\n            <xsl:attribute name="m:val">\r\n              <xsl:value-of select="$chClose" />\r\n            </xsl:attribute>\r\n          </m:endChr>\r\n        </xsl:if>\r\n      </m:dPr>\r\n    </xsl:if>\r\n  </xsl:template>\r\n\r\n  <xsl:template name="LQuoteFromMs">\r\n    <xsl:param name="msCur" select="." />\r\n    <xsl:choose>\r\n      <xsl:when test="(not($msCur/@lquote) or $msCur/@lquote='')\r\n                      and (not($msCur/@mml:lquote) or $msCur/@mml:lquote='')">\r\n        <xsl:text>"</xsl:text>\r\n      </xsl:when>\r\n      <xsl:otherwise>\r\n        <xsl:choose>\r\n          <xsl:when test="$msCur/@lquote">\r\n            <xsl:value-of select="$msCur/@lquote"/>\r\n          </xsl:when>\r\n          <xsl:otherwise>\r\n            <xsl:value-of select="$msCur/@mml:lquote"/>\r\n          </xsl:otherwise>\r\n        </xsl:choose>\r\n      </xsl:otherwise>\r\n    </xsl:choose>\r\n  </xsl:template>\r\n\r\n  <xsl:template name="RQuoteFromMs">\r\n    <xsl:param name="msCur" select="." />\r\n    <xsl:choose>\r\n      <xsl:when test="(not($msCur/@rquote) or $msCur/@rquote='')\r\n                       and (not($msCur/@mml:rquote) or $msCur/@mml:rquote='')">\r\n        <xsl:text>"</xsl:text>\r\n      </xsl:when>\r\n      <xsl:otherwise>\r\n        <xsl:choose>\r\n          <xsl:when test="$msCur/@rquote">\r\n            <xsl:value-of select="$msCur/@rquote"/>\r\n          </xsl:when>\r\n          <xsl:otherwise>\r\n            <xsl:value-of select="$msCur/@mml:rquote"/>\r\n          </xsl:otherwise>\r\n        </xsl:choose>\r\n      </xsl:otherwise>\r\n    </xsl:choose>\r\n  </xsl:template>\r\n\r\n  <!-- %%Template: OutputMs\r\n\t-->\r\n  <xsl:template name="OutputMs">\r\n    <xsl:param name="msCur" />\r\n\r\n    <xsl:variable name="chLquote">\r\n      <xsl:call-template name="LQuoteFromMs">\r\n        <xsl:with-param name="msCur" select="$msCur" />\r\n      </xsl:call-template>\r\n    </xsl:variable>\r\n\r\n    <xsl:variable name="chRquote">\r\n      <xsl:call-template name="RQuoteFromMs">\r\n        <xsl:with-param name="msCur" select="$msCur" />\r\n      </xsl:call-template>\r\n    </xsl:variable>\r\n\r\n    <xsl:value-of select="$chLquote"/>\r\n    <xsl:value-of select="normalize-space($msCur)" />\r\n    <xsl:value-of select="$chRquote"/>\r\n  </xsl:template>\r\n\r\n  <!-- %%Template: match msub\r\n\t-->\r\n  <xsl:template match="mml:msub">\r\n    <xsl:variable name="fNary">\r\n      <xsl:call-template name="isNary">\r\n        <xsl:with-param name="ndCur" select="child::*[1]" />\r\n      </xsl:call-template>\r\n    </xsl:variable>\r\n    <xsl:choose>\r\n      <xsl:when test="$fNary='true'">\r\n        <m:nary>\r\n          <xsl:call-template name="CreateNaryProp">\r\n            <xsl:with-param name="chr">\r\n              <xsl:value-of select="normalize-space(child::*[1])" />\r\n            </xsl:with-param>\r\n            <xsl:with-param name="sMathmlType" select="'msub'" />\r\n          </xsl:call-template>\r\n          <m:sub>\r\n            <xsl:call-template name="CreateArgProp" />\r\n            <xsl:apply-templates select="child::*[2]" />\r\n          </m:sub>\r\n          <m:sup>\r\n            <xsl:call-template name="CreateArgProp" />\r\n          </m:sup>\r\n          <m:e>\r\n            <xsl:call-template name="CreateArgProp" />\r\n            <xsl:call-template name="NaryHandleMrowMstyle">\r\n              <xsl:with-param name="ndCur" select="following-sibling::*[1]" />\r\n            </xsl:call-template>\r\n          </m:e>\r\n        </m:nary>\r\n      </xsl:when>\r\n      <xsl:otherwise>\r\n        <m:sSub>\r\n          <m:e>\r\n            <xsl:call-template name="CreateArgProp" />\r\n            <xsl:apply-templates select="child::*[1]" />\r\n          </m:e>\r\n          <m:sub>\r\n            <xsl:call-template name="CreateArgProp" />\r\n            <xsl:apply-templates select="child::*[2]" />\r\n          </m:sub>\r\n        </m:sSub>\r\n      </xsl:otherwise>\r\n    </xsl:choose>\r\n  </xsl:template>\r\n\r\n  <!-- %%Template: match msup\r\n\t-->\r\n  <xsl:template match="mml:msup">\r\n    <xsl:variable name="fNary">\r\n      <xsl:call-template name="isNary">\r\n        <xsl:with-param name="ndCur" select="child::*[1]" />\r\n      </xsl:call-template>\r\n    </xsl:variable>\r\n    <xsl:choose>\r\n      <xsl:when test="$fNary='true'">\r\n        <m:nary>\r\n          <xsl:call-template name="CreateNaryProp">\r\n            <xsl:with-param name="chr">\r\n              <xsl:value-of select="normalize-space(child::*[1])" />\r\n            </xsl:with-param>\r\n            <xsl:with-param name="sMathmlType" select="'msup'" />\r\n          </xsl:call-template>\r\n          <m:sub>\r\n            <xsl:call-template name="CreateArgProp" />\r\n          </m:sub>\r\n          <m:sup>\r\n            <xsl:call-template name="CreateArgProp" />\r\n            <xsl:apply-templates select="child::*[2]" />\r\n          </m:sup>\r\n          <m:e>\r\n            <xsl:call-template name="CreateArgProp" />\r\n            <xsl:call-template name="NaryHandleMrowMstyle">\r\n              <xsl:with-param name="ndCur" select="following-sibling::*[1]" />\r\n            </xsl:call-template>\r\n          </m:e>\r\n        </m:nary>\r\n      </xsl:when>\r\n      <xsl:otherwise>\r\n        <m:sSup>\r\n          <m:e>\r\n            <xsl:call-template name="CreateArgProp" />\r\n            <xsl:apply-templates select="child::*[1]" />\r\n          </m:e>\r\n          <m:sup>\r\n            <xsl:call-template name="CreateArgProp" />\r\n            <xsl:apply-templates select="child::*[2]" />\r\n          </m:sup>\r\n        </m:sSup>\r\n      </xsl:otherwise>\r\n    </xsl:choose>\r\n  </xsl:template>\r\n\r\n  <!-- %%Template: match msubsup\r\n\t-->\r\n  <xsl:template match="mml:msubsup">\r\n    <xsl:variable name="fNary">\r\n      <xsl:call-template name="isNary">\r\n        <xsl:with-param name="ndCur" select="child::*[1]" />\r\n      </xsl:call-template>\r\n    </xsl:variable>\r\n    <xsl:choose>\r\n      <xsl:when test="$fNary='true'">\r\n        <m:nary>\r\n          <xsl:call-template name="CreateNaryProp">\r\n            <xsl:with-param name="chr">\r\n              <xsl:value-of select="normalize-space(child::*[1])" />\r\n            </xsl:with-param>\r\n            <xsl:with-param name="sMathmlType" select="'msubsup'" />\r\n          </xsl:call-template>\r\n          <m:sub>\r\n            <xsl:call-template name="CreateArgProp" />\r\n            <xsl:apply-templates select="child::*[2]" />\r\n          </m:sub>\r\n          <m:sup>\r\n            <xsl:call-template name="CreateArgProp" />\r\n            <xsl:apply-templates select="child::*[3]" />\r\n          </m:sup>\r\n          <m:e>\r\n            <xsl:call-template name="CreateArgProp" />\r\n            <xsl:call-template name="NaryHandleMrowMstyle">\r\n              <xsl:with-param name="ndCur" select="following-sibling::*[1]" />\r\n            </xsl:call-template>\r\n          </m:e>\r\n        </m:nary>\r\n      </xsl:when>\r\n      <xsl:otherwise>\r\n        <m:sSubSup>\r\n          <m:e>\r\n            <xsl:call-template name="CreateArgProp" />\r\n            <xsl:apply-templates select="child::*[1]" />\r\n          </m:e>\r\n          <m:sub>\r\n            <xsl:call-template name="CreateArgProp" />\r\n            <xsl:apply-templates select="child::*[2]" />\r\n          </m:sub>\r\n          <m:sup>\r\n            <xsl:call-template name="CreateArgProp" />\r\n            <xsl:apply-templates select="child::*[3]" />\r\n          </m:sup>\r\n        </m:sSubSup>\r\n      </xsl:otherwise>\r\n    </xsl:choose>\r\n  </xsl:template>\r\n\r\n  <!-- %%Template: SplitScripts \r\n\t\r\n\t\tTakes an collection of nodes, and splits them\r\n\t\todd and even into sup and sub scripts. Used for dealing with\r\n\t\tmmultiscript.\r\n\t\t\r\n\t\tThis template assumes you want to output both a sub and sup element.\r\n\t\t-->\r\n  <xsl:template name="SplitScripts">\r\n    <xsl:param name="ndScripts" />\r\n    <m:sub>\r\n      <xsl:call-template name="CreateArgProp" />\r\n      <xsl:apply-templates select="$ndScripts[(position() mod 2) = 1]" />\r\n    </m:sub>\r\n    <m:sup>\r\n      <xsl:call-template name="CreateArgProp" />\r\n      <xsl:apply-templates select="$ndScripts[(position() mod 2) = 0]" />\r\n    </m:sup>\r\n  </xsl:template>\r\n\r\n  <!-- %%Template: match mmultiscripts\r\n\t\r\n\t\tThere is some subtlety with the mml:mprescripts element. Everything that comes before \r\n\t\tthat is considered a script (as opposed to a pre-script), but it need not be present.\r\n\t-->\r\n  <xsl:template match="mml:mmultiscripts">\r\n\r\n    <!-- count the nodes. Everything that comes after a mml:mprescripts is considered a pre-script;\r\n\t\t\tEverything that does not have an mml:mprescript as a preceding-sibling (and is not itself \r\n\t\t\tmml:mprescript) is a script, except for the first child which is always the base.\r\n\t\t\tThe mml:none element is a place holder for a sub/sup element slot.\r\n\t\t\t\r\n\t\t\tmmultisript pattern:\r\n\t\t\t<mmultiscript>\r\n\t\t\t\t(base)\r\n\t\t\t\t(sub sup)* // Where <none/> can replace a sub/sup entry to preserve pattern.\r\n\t\t\t\t<mprescripts />\r\n\t\t\t\t(presub presup)*\r\n\t\t\t</mmultiscript>\r\n\t\t\t-->\r\n    <!-- Count of presecript nodes that we'd print (this is essentially anything but the none placeholder. -->\r\n    <xsl:variable name="cndPrescriptStrict" select="count(mml:mprescripts[1]/following-sibling::*[not(self::mml:none)])" />\r\n    <!-- Count of all super script excluding mml:none -->\r\n    <xsl:variable name="cndSuperScript" select="count(*[not(preceding-sibling::mml:mprescripts)\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tand not(self::mml:mprescripts)\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tand ((position() mod 2) = 1) \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tand not(self::mml:none)]) - 1"/>\r\n    <!-- Count of all sup script excluding mml:none -->\r\n    <xsl:variable name="cndSubScript" select="count(*[not(preceding-sibling::mml:mprescripts)\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tand not(self::mml:mprescripts)\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tand ((position() mod 2) = 0) \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tand not(self::mml:none)])"/>\r\n    <!-- Count of all scripts excluding mml:none -->\r\n    <xsl:variable name="cndScriptStrict" select="$cndSuperScript + $cndSubScript" />\r\n    <!-- Count of all scripts including mml:none.  This is essentially all nodes before the \r\n\t\tfirst mml:mprescripts except the base. -->\r\n    <xsl:variable name="cndScript" select="count(*[not(preceding-sibling::mml:mprescripts) and not(self::mml:mprescripts)]) - 1" />\r\n\r\n    <xsl:choose>\r\n      <!-- The easy case first. No prescripts, and no script ... just a base -->\r\n      <xsl:when test="$cndPrescriptStrict &lt;= 0 and $cndScriptStrict &lt;= 0">\r\n        <xsl:apply-templates select="*[1]" />\r\n      </xsl:when>\r\n\r\n      <!-- Next, if there are no prescripts -->\r\n      <xsl:when test="$cndPrescriptStrict &lt;= 0">\r\n        <!-- we know we have some scripts or else we would have taken the earlier\r\n\t\t\t\t\t  branch. -->\r\n        <xsl:choose>\r\n          <!-- We have both sub and super scripts-->\r\n          <xsl:when test="$cndSuperScript &gt; 0 and $cndSubScript &gt; 0">\r\n            <m:sSubSup>\r\n              <m:e>\r\n                <xsl:call-template name="CreateArgProp" />\r\n                <xsl:apply-templates select="child::*[1]" />\r\n              </m:e>\r\n\r\n              <!-- Every child except the first is a script.  Do the split -->\r\n              <xsl:call-template name="SplitScripts">\r\n                <xsl:with-param name="ndScripts" select="*[position() &gt; 1]" />\r\n              </xsl:call-template>\r\n            </m:sSubSup>\r\n          </xsl:when>\r\n          <!-- Just a sub script -->\r\n          <xsl:when test="$cndSubScript &gt; 0">\r\n            <m:sSub>\r\n              <m:e>\r\n                <xsl:call-template name="CreateArgProp" />\r\n                <xsl:apply-templates select="child::*[1]" />\r\n              </m:e>\r\n\r\n              <!-- No prescripts and no super scripts, therefore, it's a sub. -->\r\n              <m:sub>\r\n                <xsl:apply-templates select="*[position() &gt; 1]" />\r\n              </m:sub>\r\n            </m:sSub>\r\n          </xsl:when>\r\n          <!-- Just super script -->\r\n          <xsl:otherwise>\r\n            <m:sSup>\r\n              <m:e>\r\n                <xsl:call-template name="CreateArgProp" />\r\n                <xsl:apply-templates select="child::*[1]" />\r\n              </m:e>\r\n\r\n              <!-- No prescripts and no sub scripts, therefore, it's a sup. -->\r\n              <m:sup>\r\n                <xsl:apply-templates select="*[position() &gt; 1]" />\r\n              </m:sup>\r\n            </m:sSup>\r\n          </xsl:otherwise>\r\n        </xsl:choose>\r\n      </xsl:when>\r\n\r\n      <!-- Next, if there are no scripts -->\r\n      <xsl:when test="$cndScriptStrict &lt;= 0">\r\n        <!-- we know we have some prescripts or else we would have taken the earlier\r\n\t\t\t\t\t  branch. So, create an sPre and split the elements -->\r\n        <m:sPre>\r\n          <m:e>\r\n            <xsl:call-template name="CreateArgProp" />\r\n            <xsl:apply-templates select="child::*[1]" />\r\n          </m:e>\r\n\r\n          <!-- The prescripts come after the mml:mprescript and if we get here\r\n\t\t\t\t\t\t\twe know there exists some elements after the mml:mprescript element. \r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tThe prescript element has no sub/subsup variation, therefore, even if\r\n\t\t\t\t\t\t\twe're only writing sub, we need to write out both the sub and sup element.\r\n\t\t\t\t\t\t\t-->\r\n          <xsl:call-template name="SplitScripts">\r\n            <xsl:with-param name="ndScripts" select="mml:mprescripts[1]/following-sibling::*" />\r\n          </xsl:call-template>\r\n        </m:sPre>\r\n      </xsl:when>\r\n\r\n      <!-- Finally, the case with both prescripts and scripts. Create an sPre \r\n\t\t\t\telement to house the prescripts, with a sub/sup/subsup element at its base. -->\r\n      <xsl:otherwise>\r\n        <m:sPre>\r\n          <m:e>\r\n            <xsl:choose>\r\n              <!-- We have both sub and super scripts-->\r\n              <xsl:when test="$cndSuperScript &gt; 0 and $cndSubScript &gt; 0">\r\n                <m:sSubSup>\r\n                  <m:e>\r\n                    <xsl:call-template name="CreateArgProp" />\r\n                    <xsl:apply-templates select="child::*[1]" />\r\n                  </m:e>\r\n\r\n                  <!-- scripts come before the mml:mprescript but after the first child, so their\r\n\t\t\t\t\t\t\t\t positions will be 2, 3, ... ($nndScript + 1) -->\r\n                  <xsl:call-template name="SplitScripts">\r\n                    <xsl:with-param name="ndScripts" select="*[(position() &gt; 1) and (position() &lt;= ($cndScript + 1))]" />\r\n                  </xsl:call-template>\r\n                </m:sSubSup>\r\n              </xsl:when>\r\n              <!-- Just a sub script -->\r\n              <xsl:when test="$cndSubScript &gt; 0">\r\n                <m:sSub>\r\n                  <m:e>\r\n                    <xsl:call-template name="CreateArgProp" />\r\n                    <xsl:apply-templates select="child::*[1]" />\r\n                  </m:e>\r\n\r\n                  <!-- We have prescripts but no super scripts, therefore, do a sub \r\n\t\t\t\t\t\t\t\t\tand apply templates to all tokens counted by cndScript. -->\r\n                  <m:sub>\r\n                    <xsl:apply-templates select="*[position() &gt; 1 and (position() &lt;= ($cndScript + 1))]" />\r\n                  </m:sub>\r\n                </m:sSub>\r\n              </xsl:when>\r\n              <!-- Just super script -->\r\n              <xsl:otherwise>\r\n                <m:sSup>\r\n                  <m:e>\r\n                    <xsl:call-template name="CreateArgProp" />\r\n                    <xsl:apply-templates select="child::*[1]" />\r\n                  </m:e>\r\n\r\n                  <!-- We have prescripts but no sub scripts, therefore, do a sub \r\n\t\t\t\t\t\t\t\t\tand apply templates to all tokens counted by cndScript. -->\r\n                  <m:sup>\r\n                    <xsl:apply-templates select="*[position() &gt; 1 and (position() &lt;= ($cndScript + 1))]" />\r\n                  </m:sup>\r\n                </m:sSup>\r\n              </xsl:otherwise>\r\n            </xsl:choose>\r\n          </m:e>\r\n\r\n          <!-- The prescripts come after the mml:mprescript and if we get here\r\n\t\t\t\t\t\t\twe know there exists one such element -->\r\n          <xsl:call-template name="SplitScripts">\r\n            <xsl:with-param name="ndScripts" select="mml:mprescripts[1]/following-sibling::*" />\r\n          </xsl:call-template>\r\n        </m:sPre>\r\n      </xsl:otherwise>\r\n    </xsl:choose>\r\n  </xsl:template>\r\n\r\n  <!-- Template that determines if ndCur is an equation array.\r\n\t\t\t\t\r\n\t\t\t ndCur is an equation array if:\r\n\t\t\t \r\n\t\t\t 1.  There are are no frame lines\r\n\t\t\t 2.  There are no column lines\r\n\t\t\t 3.  There are no row lines\r\n\t\t\t 4.  There is no row with more than 1 column  \r\n\t\t\t 5.  There is no row with fewer than 1 column\r\n\t\t\t 6.  There are no labeled rows.\r\n\t\t\t \r\n\t-->\r\n  <xsl:template name="FIsEqArray">\r\n    <xsl:param name="ndCur" select="." />\r\n\r\n    <!-- There should be no frame, columnlines, or rowlines -->\r\n    <xsl:choose>\r\n      <xsl:when test="(not($ndCur/@frame) or $ndCur/@frame='' or $ndCur/@frame='none')\r\n                      and (not($ndCur/@mml:frame) or $ndCur/@mml:frame='' or $ndCur/@mml:frame='none')\r\n\t\t\t\t\t\t\t\t      and (not($ndCur/@columnlines) or $ndCur/@columnlines='' or $ndCur/@columnlines='none')\r\n                      and (not($ndCur/@mml:columnlines) or $ndCur/@mml:columnlines='' or $ndCur/@mml:columnlines='none')\r\n\t\t\t\t\t\t\t\t      and (not($ndCur/@rowlines) or $ndCur/@rowlines='' or $ndCur/@rowlines='none')\r\n                      and (not($ndCur/@mml:rowlines) or $ndCur/@mml:rowlines='' or $ndCur/@mml:rowlines='none')\r\n\t\t\t\t\t\t\t\t      and not($ndCur/mml:mtr[count(mml:mtd) &gt; 1])\r\n\t\t\t\t\t\t\t\t\t\t\tand not($ndCur/mml:mtr[count(mml:mtd) &lt; 1])\r\n\t\t\t\t\t\t\t\t      and not($ndCur/mml:mlabeledtr)">1</xsl:when>\r\n      <xsl:otherwise>0</xsl:otherwise>\r\n    </xsl:choose>\r\n  </xsl:template>\r\n\r\n  <!-- Template used to determine if we should ignore a collection when iterating through \r\n\t     a mathml equation array row.\r\n\t\r\n\t\t\t So far, the only thing that needs to be ignored is the argument of an nary.  We\r\n\t\t\t can ignore this since it is output when we apply-templates to the munder[over]/msub[sup].\r\n\t-->\r\n  <xsl:template name="FIgnoreCollection">\r\n    <xsl:param name="ndCur" select="." />\r\n\r\n    <xsl:variable name="fNaryArgument">\r\n      <xsl:call-template name="FIsNaryArgument">\r\n        <xsl:with-param name="ndCur" select="$ndCur" />\r\n      </xsl:call-template>\r\n    </xsl:variable>\r\n\r\n    <xsl:choose>\r\n      <xsl:when test="$fNaryArgument=1">1</xsl:when>\r\n      <xsl:otherwise>0</xsl:otherwise>\r\n    </xsl:choose>\r\n  </xsl:template>\r\n\r\n  <!-- Template used to determine if we've already encountered an maligngroup or malignmark.\r\n\t\r\n\t\t\t This is needed because omml has an implicit spacing alignment (omml spacing alignment = \r\n\t\t\t mathml's maligngroup element) at the beginning of each equation array row.  Therefore, \r\n\t\t\t the first maligngroup (implied or explicit) we encounter does not need to be output.  \r\n\t\t\t This template recursively searches up the xml tree and looks at previous siblings to see \r\n\t\t\t if they have a descendant that is an maligngroup or malignmark.  We look for the malignmark \r\n\t\t\t to find the implicit maligngroup.\r\n\t-->\r\n  <xsl:template name="FFirstAlignAlreadyFound">\r\n    <xsl:param name="ndCur" select="." />\r\n\r\n    <xsl:choose>\r\n      <xsl:when test="count($ndCur/preceding-sibling::*[descendant-or-self::mml:maligngroup\r\n\t\t\t\t\t\t\t\t                                        or descendant-or-self::mml:malignmark]) &gt; 0">1</xsl:when>\r\n      <xsl:when test="not($ndCur/parent::mml:mtd)">\r\n        <xsl:call-template name="FFirstAlignAlreadyFound">\r\n          <xsl:with-param name="ndCur" select="$ndCur/parent::*" />\r\n        </xsl:call-template>\r\n      </xsl:when>\r\n      <xsl:otherwise>0</xsl:otherwise>\r\n    </xsl:choose>\r\n  </xsl:template>\r\n\r\n  <!-- This template builds a string that is result of concatenating a given string several times. \r\n\t\r\n\t\t\t Given strToRepeat, create a string that has strToRepeat repeated iRepitions times. \r\n\t-->\r\n  <xsl:template name="ConcatStringRepeat">\r\n    <xsl:param name="strToRepeat" select="''" />\r\n    <xsl:param name="iRepetitions" select="0" />\r\n    <xsl:param name="strBuilding" select="''" />\r\n\r\n    <xsl:choose>\r\n      <xsl:when test="$iRepetitions &lt;= 0">\r\n        <xsl:value-of select="$strBuilding" />\r\n      </xsl:when>\r\n      <xsl:otherwise>\r\n        <xsl:call-template name="ConcatStringRepeat">\r\n          <xsl:with-param name="strToRepeat" select="$strToRepeat" />\r\n          <xsl:with-param name="iRepetitions" select="$iRepetitions - 1" />\r\n          <xsl:with-param name="strBuilding" select="concat($strBuilding, $strToRepeat)" />\r\n        </xsl:call-template>\r\n      </xsl:otherwise>\r\n    </xsl:choose>\r\n  </xsl:template>\r\n\r\n  <!-- This template determines if ndCur is a special collection.\r\n\t\t\t By special collection, I mean is ndCur the outer element of some special grouping \r\n\t\t\t of mathml elements that actually represents some over all omml structure.\r\n\t\t\t \r\n\t\t\t For instance, is ndCur a linear fraction, or an omml function.\r\n\t-->\r\n  <xsl:template name="FSpecialCollection">\r\n    <xsl:param name="ndCur" select="." />\r\n    <xsl:choose>\r\n      <xsl:when test="$ndCur/self::mml:mrow">\r\n        <xsl:variable name="fLinearFraction">\r\n          <xsl:call-template name="FLinearFrac">\r\n            <xsl:with-param name="ndCur" select="$ndCur"/>\r\n          </xsl:call-template>\r\n        </xsl:variable>\r\n        <xsl:variable name="fFunc">\r\n          <xsl:call-template name="FIsFunc">\r\n            <xsl:with-param name="ndCur" select="$ndCur" />\r\n          </xsl:call-template>\r\n        </xsl:variable>\r\n        <xsl:choose>\r\n          <xsl:when test="$fLinearFraction=1 or $fFunc=1">1</xsl:when>\r\n          <xsl:otherwise>0</xsl:otherwise>\r\n        </xsl:choose>\r\n      </xsl:when>\r\n      <xsl:otherwise>0</xsl:otherwise>\r\n    </xsl:choose>\r\n  </xsl:template>\r\n\r\n  <!-- This template iterates through the children of an equation array row (mtr) and outputs\r\n\t     the equation.\r\n\t\t\t \r\n\t\t\t This template does all the work to output ampersands and skip the right elements when needed.\r\n\t-->\r\n  <xsl:template name="ProcessEqArrayRow">\r\n    <xsl:param name="ndCur" select="." />\r\n\r\n    <xsl:for-each select="$ndCur/*">\r\n      <xsl:variable name="fSpecialCollection">\r\n        <xsl:call-template name="FSpecialCollection">\r\n          <xsl:with-param name="ndCur" select="." />\r\n        </xsl:call-template>\r\n      </xsl:variable>\r\n      <xsl:variable name="fIgnoreCollection">\r\n        <xsl:call-template name="FIgnoreCollection">\r\n          <xsl:with-param name="ndCur" select="." />\r\n        </xsl:call-template>\r\n      </xsl:variable>\r\n      <xsl:choose>\r\n        <!-- If we have an alignment element output the ampersand. -->\r\n        <xsl:when test="self::mml:maligngroup or self::mml:malignmark">\r\n          <!-- Omml has an implied spacing alignment at the beginning of each equation.\r\n\t\t\t\t\t     Therefore, if this is the first ampersand to be output, don't actually output. -->\r\n          <xsl:variable name="fFirstAlignAlreadyFound">\r\n            <xsl:call-template name="FFirstAlignAlreadyFound">\r\n              <xsl:with-param name="ndCur" select="." />\r\n            </xsl:call-template>\r\n          </xsl:variable>\r\n          <!-- Don't output unless it is an malignmark or we have already previously found an alignment point. -->\r\n          <xsl:if test="self::mml:malignmark or $fFirstAlignAlreadyFound=1">\r\n            <m:r>\r\n              <m:t>&amp;</m:t>\r\n            </m:r>\r\n          </xsl:if>\r\n        </xsl:when>\r\n        <!-- If this node is an non-special mrow or mstyle and we aren't supposed to ignore this collection, then\r\n\t\t\t\t     go ahead an apply templates to this node. -->\r\n        <xsl:when test="$fIgnoreCollection=0 and ((self::mml:mrow and $fSpecialCollection=0) or self::mml:mstyle)">\r\n          <xsl:call-template name="ProcessEqArrayRow">\r\n            <xsl:with-param name="ndCur" select="." />\r\n          </xsl:call-template>\r\n        </xsl:when>\r\n        <!-- At this point we have some mathml structure (fraction, nary, non-grouping element, etc.) -->\r\n        <!-- If this mathml structure has alignment groups or marks as children, then extract those since\r\n\t\t\t\t     omml can't handle that. -->\r\n        <xsl:when test="descendant::mml:maligngroup or descendant::mml:malignmark">\r\n          <xsl:variable name="cMalignGroups">\r\n            <xsl:value-of select="count(descendant::mml:maligngroup)" />\r\n          </xsl:variable>\r\n          <xsl:variable name="cMalignMarks">\r\n            <xsl:value-of select="count(descendant::mml:malignmark)" />\r\n          </xsl:variable>\r\n          <!-- Output all maligngroups and malignmarks as '&' -->\r\n          <xsl:if test="$cMalignGroups + $cMalignMarks &gt; 0">\r\n            <xsl:variable name="str">\r\n              <xsl:call-template name="ConcatStringRepeat">\r\n                <xsl:with-param name="strToRepeat" select="'&amp;'" />\r\n                <xsl:with-param name="iRepetitions" select="$cMalignGroups + $cMalignMarks" />\r\n                <xsl:with-param name="strBuilding" select="''" />\r\n              </xsl:call-template>\r\n            </xsl:variable>\r\n            <xsl:element name="m:r">\r\n              <xsl:element name="m:t">\r\n                <xsl:call-template name="OutputText">\r\n                  <xsl:with-param name="sInput" select="$str" />\r\n                </xsl:call-template>\r\n              </xsl:element>\r\n            </xsl:element>\r\n          </xsl:if>\r\n          <!-- Now that the '&' have been extracted, just apply-templates to this node.-->\r\n          <xsl:apply-templates select="." />\r\n        </xsl:when>\r\n        <!-- If there are no alignment points as descendants, then go ahead and output this node. -->\r\n        <xsl:otherwise>\r\n          <xsl:apply-templates select="." />\r\n        </xsl:otherwise>\r\n      </xsl:choose>\r\n    </xsl:for-each>\r\n  </xsl:template>\r\n\r\n  <!-- This template transforms mtable into its appropriate omml type.\r\n\t\r\n\t\t\t There are two possible omml constructs that an mtable can become:  a matrix or \r\n\t\t\t an equation array.\r\n\t\t\t \r\n\t\t\t Because omml has no generic table construct, the omml matrix is the best approximate\r\n\t\t\t for a mathml table.\r\n\t\t\t \r\n\t\t\t Our equation array transformation is very simple.  The main goal of this transform is to\r\n\t\t\t allow roundtripping omml eq arrays through mathml.  The template ProcessEqArrayRow was never\r\n\t\t\t intended to account for many of the alignment flexibilities that are present in mathml like \r\n\t\t\t using the alig attribute, using alignmark attribute in token elements, etc.\r\n\t\t\t \r\n\t\t\t The restrictions on this transform require <malignmark> and <maligngroup> elements to be outside of\r\n\t\t\t any non-grouping mathml elements (that is, mrow and mstyle).  Moreover, these elements cannot be the children of\r\n\t\t\t mrows that represent linear fractions or functions.  Also, <malignmark> cannot be a child\r\n\t\t\t of token attributes.\r\n\t\t\t \r\n\t\t\t In the case that the above \r\n\t\r\n\t-->\r\n  <xsl:template match="mml:mtable">\r\n    <xsl:variable name="fEqArray">\r\n      <xsl:call-template name="FIsEqArray">\r\n        <xsl:with-param name="ndCur" select="." />\r\n      </xsl:call-template>\r\n    </xsl:variable>\r\n    <xsl:choose>\r\n      <xsl:when test="$fEqArray=1">\r\n        <xsl:element name="m:eqArr">\r\n          <xsl:for-each select="mml:mtr">\r\n            <xsl:element name="m:e">\r\n              <xsl:call-template name="ProcessEqArrayRow">\r\n                <xsl:with-param name="ndCur" select="mml:mtd" />\r\n              </xsl:call-template>\r\n            </xsl:element>\r\n          </xsl:for-each>\r\n        </xsl:element>\r\n      </xsl:when>\r\n      <xsl:otherwise>\r\n        <xsl:variable name="cMaxElmtsInRow">\r\n          <xsl:call-template name="CountMaxElmtsInRow">\r\n            <xsl:with-param name="ndCur" select="*[1]" />\r\n            <xsl:with-param name="cMaxElmtsInRow" select="0" />\r\n          </xsl:call-template>\r\n        </xsl:variable>\r\n        <m:m>\r\n          <m:mPr>\r\n            <m:baseJc m:val="center" />\r\n            <m:plcHide m:val="on" />\r\n            <m:mcs>\r\n              <m:mc>\r\n                <m:mcPr>\r\n                  <m:count>\r\n                    <xsl:attribute name="m:val">\r\n                      <xsl:value-of select="$cMaxElmtsInRow" />\r\n                    </xsl:attribute>\r\n                  </m:count>\r\n                  <m:mcJc m:val="center" />\r\n                </m:mcPr>\r\n              </m:mc>\r\n            </m:mcs>\r\n          </m:mPr>\r\n          <xsl:for-each select="*">\r\n            <xsl:choose>\r\n              <xsl:when test="self::mml:mtr or self::mml:mlabeledtr">\r\n                <m:mr>\r\n                  <xsl:choose>\r\n                    <xsl:when test="self::mml:mtr">\r\n                      <xsl:for-each select="*">\r\n                        <m:e>\r\n                          <xsl:apply-templates select="." />\r\n                        </m:e>\r\n                      </xsl:for-each>\r\n                      <xsl:call-template name="CreateEmptyElmt">\r\n                        <xsl:with-param name="cEmptyMtd" select="$cMaxElmtsInRow - count(*)" />\r\n                      </xsl:call-template>\r\n                    </xsl:when>\r\n                    <xsl:otherwise>\r\n                      <xsl:for-each select="*[position() &gt; 1]">\r\n                        <m:e>\r\n                          <xsl:apply-templates select="." />\r\n                        </m:e>\r\n                      </xsl:for-each>\r\n                      <xsl:call-template name="CreateEmptyElmt">\r\n                        <xsl:with-param name="cEmptyMtd" select="$cMaxElmtsInRow - (count(*) - 1)" />\r\n                      </xsl:call-template>\r\n                    </xsl:otherwise>\r\n                  </xsl:choose>\r\n                </m:mr>\r\n              </xsl:when>\r\n              <xsl:otherwise>\r\n                <m:mr>\r\n                  <m:e>\r\n                    <xsl:apply-templates select="." />\r\n                  </m:e>\r\n                  <xsl:call-template name="CreateEmptyElmt">\r\n                    <xsl:with-param name="cEmptyMtd" select="$cMaxElmtsInRow - 1" />\r\n                  </xsl:call-template>\r\n                </m:mr>\r\n              </xsl:otherwise>\r\n            </xsl:choose>\r\n          </xsl:for-each>\r\n        </m:m>\r\n      </xsl:otherwise>\r\n    </xsl:choose>\r\n  </xsl:template>\r\n  <xsl:template match="m:mtd">\r\n    <xsl:apply-templates select="*" />\r\n  </xsl:template>\r\n  <xsl:template name="CreateEmptyElmt">\r\n    <xsl:param name="cEmptyMtd" />\r\n    <xsl:if test="$cEmptyMtd &gt; 0">\r\n      <m:e></m:e>\r\n      <xsl:call-template name="CreateEmptyElmt">\r\n        <xsl:with-param name="cEmptyMtd" select="$cEmptyMtd - 1" />\r\n      </xsl:call-template>\r\n    </xsl:if>\r\n  </xsl:template>\r\n  <xsl:template name="CountMaxElmtsInRow">\r\n    <xsl:param name="ndCur" />\r\n    <xsl:param name="cMaxElmtsInRow" select="0" />\r\n    <xsl:choose>\r\n      <xsl:when test="not($ndCur)">\r\n        <xsl:value-of select="$cMaxElmtsInRow" />\r\n      </xsl:when>\r\n      <xsl:otherwise>\r\n        <xsl:call-template name="CountMaxElmtsInRow">\r\n          <xsl:with-param name="ndCur" select="$ndCur/following-sibling::*[1]" />\r\n          <xsl:with-param name="cMaxElmtsInRow">\r\n            <xsl:choose>\r\n              <xsl:when test="local-name($ndCur) = 'mlabeledtr' and \r\n\t\t\t\t\t\t\t\t            namespace-uri($ndCur) = 'http://www.w3.org/1998/Math/MathML'">\r\n                <xsl:choose>\r\n                  <xsl:when test="(count($ndCur/*) - 1) &gt; $cMaxElmtsInRow">\r\n                    <xsl:value-of select="count($ndCur/*) - 1" />\r\n                  </xsl:when>\r\n                  <xsl:otherwise>\r\n                    <xsl:value-of select="$cMaxElmtsInRow" />\r\n                  </xsl:otherwise>\r\n                </xsl:choose>\r\n              </xsl:when>\r\n              <xsl:when test="local-name($ndCur) = 'mtr' and \r\n\t\t\t\t\t\t\t\t            namespace-uri($ndCur) = 'http://www.w3.org/1998/Math/MathML'">\r\n                <xsl:choose>\r\n                  <xsl:when test="count($ndCur/*) &gt; $cMaxElmtsInRow">\r\n                    <xsl:value-of select="count($ndCur/*)" />\r\n                  </xsl:when>\r\n                  <xsl:otherwise>\r\n                    <xsl:value-of select="$cMaxElmtsInRow" />\r\n                  </xsl:otherwise>\r\n                </xsl:choose>\r\n              </xsl:when>\r\n              <xsl:otherwise>\r\n                <xsl:choose>\r\n                  <xsl:when test="1 &gt; $cMaxElmtsInRow">\r\n                    <xsl:value-of select="1" />\r\n                  </xsl:when>\r\n                  <xsl:otherwise>\r\n                    <xsl:value-of select="$cMaxElmtsInRow" />\r\n                  </xsl:otherwise>\r\n                </xsl:choose>\r\n              </xsl:otherwise>\r\n            </xsl:choose>\r\n          </xsl:with-param>\r\n        </xsl:call-template>\r\n      </xsl:otherwise>\r\n    </xsl:choose>\r\n  </xsl:template>\r\n\r\n  <xsl:template name="GetMglyphAltText">\r\n    <xsl:param name="ndCur" select="." />\r\n    <xsl:choose>\r\n      <xsl:when test="$ndCur/@alt">\r\n        <xsl:value-of select="normalize-space($ndCur/@alt)"/>\r\n      </xsl:when>\r\n      <xsl:otherwise>\r\n        <xsl:value-of select="normalize-space($ndCur/@mml:alt)"/>\r\n      </xsl:otherwise>\r\n    </xsl:choose>\r\n  </xsl:template>\r\n\r\n  <xsl:template match="mml:mglyph">\r\n    <xsl:element name="m:r">\r\n      <xsl:element name="m:rPr">\r\n        <xsl:element name="m:nor" />\r\n      </xsl:element>\r\n      <xsl:element name="m:t">\r\n        <xsl:call-template name="OutputText">\r\n          <xsl:with-param name="sInput">\r\n            <xsl:call-template name="GetMglyphAltText">\r\n              <xsl:with-param name="ndCur" select="." />\r\n            </xsl:call-template>\r\n          </xsl:with-param>\r\n        </xsl:call-template>\r\n      </xsl:element>\r\n    </xsl:element>\r\n  </xsl:template>\r\n\r\n  <!-- Omml doesn't really support mglyph, so just output the alt text -->\r\n  <xsl:template match="mml:mi[child::mml:mglyph] | \r\n\t                     mml:mn[child::mml:mglyph] | \r\n\t                     mml:mo[child::mml:mglyph] | \r\n\t                     mml:ms[child::mml:mglyph] | \r\n\t                     mml:mtext[child::mml:mglyph]">\r\n    <xsl:variable name="mathvariant">\r\n      <xsl:choose>\r\n        <xsl:when test="@mathvariant">\r\n          <xsl:value-of select="@mathvariant"/>\r\n        </xsl:when>\r\n        <xsl:otherwise>\r\n          <xsl:value-of select="@mml:mathvariant"/>\r\n        </xsl:otherwise>\r\n      </xsl:choose>\r\n    </xsl:variable>\r\n    <xsl:variable name="fontstyle">\r\n      <xsl:choose>\r\n        <xsl:when test="@fontstyle">\r\n          <xsl:value-of select="@fontstyle"/>\r\n        </xsl:when>\r\n        <xsl:otherwise>\r\n          <xsl:value-of select="@mml:fontstyle"/>\r\n        </xsl:otherwise>\r\n      </xsl:choose>\r\n    </xsl:variable>\r\n    <xsl:variable name="fontweight">\r\n      <xsl:choose>\r\n        <xsl:when test="@fontweight">\r\n          <xsl:value-of select="@fontweight"/>\r\n        </xsl:when>\r\n        <xsl:otherwise>\r\n          <xsl:value-of select="@mml:fontweight"/>\r\n        </xsl:otherwise>\r\n      </xsl:choose>\r\n    </xsl:variable>\r\n    <xsl:variable name="mathcolor">\r\n      <xsl:choose>\r\n        <xsl:when test="@mathcolor">\r\n          <xsl:value-of select="@mathcolor"/>\r\n        </xsl:when>\r\n        <xsl:otherwise>\r\n          <xsl:value-of select="@mml:mathcolor"/>\r\n        </xsl:otherwise>\r\n      </xsl:choose>\r\n    </xsl:variable>\r\n    <xsl:variable name="mathsize">\r\n      <xsl:choose>\r\n        <xsl:when test="@mathsize">\r\n          <xsl:value-of select="@mathsize"/>\r\n        </xsl:when>\r\n        <xsl:otherwise>\r\n          <xsl:value-of select="@mml:mathsize"/>\r\n        </xsl:otherwise>\r\n      </xsl:choose>\r\n    </xsl:variable>\r\n    <xsl:variable name="color">\r\n      <xsl:choose>\r\n        <xsl:when test="@color">\r\n          <xsl:value-of select="@color"/>\r\n        </xsl:when>\r\n        <xsl:otherwise>\r\n          <xsl:value-of select="@mml:color"/>\r\n        </xsl:otherwise>\r\n      </xsl:choose>\r\n    </xsl:variable>\r\n    <xsl:variable name="fontsize">\r\n      <xsl:choose>\r\n        <xsl:when test="@fontsize">\r\n          <xsl:value-of select="@fontsize"/>\r\n        </xsl:when>\r\n        <xsl:otherwise>\r\n          <xsl:value-of select="@mml:fontsize"/>\r\n        </xsl:otherwise>\r\n      </xsl:choose>\r\n    </xsl:variable>\r\n    <xsl:variable name="fNor">\r\n      <xsl:call-template name="FNor">\r\n        <xsl:with-param name="ndCur" select="." />\r\n      </xsl:call-template>\r\n    </xsl:variable>\r\n\r\n    <!-- Output MS Left Quote (if need be) -->\r\n    <xsl:if test="self::mml:ms">\r\n      <xsl:variable name="chLquote">\r\n        <xsl:call-template name="LQuoteFromMs">\r\n          <xsl:with-param name="curMs" select="." />\r\n        </xsl:call-template>\r\n      </xsl:variable>\r\n      <xsl:element name="m:r">\r\n        <xsl:call-template name="CreateRunProp">\r\n          <xsl:with-param name="mathvariant" select="$mathvariant" />\r\n          <xsl:with-param name="fontstyle" select="$fontstyle" />\r\n          <xsl:with-param name="fontweight" select="$fontweight" />\r\n          <xsl:with-param name="mathcolor" select="$mathcolor" />\r\n          <xsl:with-param name="mathsize" select="$mathsize" />\r\n          <xsl:with-param name="color" select="$color" />\r\n          <xsl:with-param name="fontsize" select="$fontsize" />\r\n          <xsl:with-param name="fNor" select="$fNor" />\r\n          <xsl:with-param name="ndCur" select="." />\r\n        </xsl:call-template>\r\n        <xsl:element name="m:t">\r\n          <xsl:call-template name="OutputText">\r\n            <xsl:with-param name="sInput" select="$chLquote"/>\r\n          </xsl:call-template>\r\n        </xsl:element>\r\n      </xsl:element>\r\n    </xsl:if>\r\n    <xsl:for-each select="mml:mglyph | text()">\r\n      <xsl:variable name="fForceNor">\r\n        <xsl:choose>\r\n          <xsl:when test="self::mml:mglyph">1</xsl:when>\r\n          <xsl:otherwise>0</xsl:otherwise>\r\n        </xsl:choose>\r\n      </xsl:variable>\r\n\r\n      <xsl:variable name="str">\r\n        <xsl:choose>\r\n          <xsl:when test="self::mml:mglyph">\r\n            <xsl:call-template name="GetMglyphAltText">\r\n              <xsl:with-param name="ndCur" select="." />\r\n            </xsl:call-template>\r\n          </xsl:when>\r\n          <xsl:otherwise>\r\n            <xsl:value-of select="normalize-space(.)"/>\r\n          </xsl:otherwise>\r\n        </xsl:choose>\r\n      </xsl:variable>\r\n      <xsl:if test="string-length($str) &gt; 0">\r\n        <xsl:element name="m:r">\r\n          <xsl:call-template name="CreateRunProp">\r\n            <xsl:with-param name="mathvariant" select="$mathvariant" />\r\n            <xsl:with-param name="fontstyle" select="$fontstyle" />\r\n            <xsl:with-param name="fontweight" select="$fontweight" />\r\n            <xsl:with-param name="mathcolor" select="$mathcolor" />\r\n            <xsl:with-param name="mathsize" select="$mathsize" />\r\n            <xsl:with-param name="color" select="$color" />\r\n            <xsl:with-param name="fontsize" select="$fontsize" />\r\n            <xsl:with-param name="fNor">\r\n              <xsl:choose>\r\n                <xsl:when test="$fForceNor=1">1</xsl:when>\r\n                <xsl:otherwise>\r\n                  <xsl:value-of select="$fNor"/>\r\n                </xsl:otherwise>\r\n              </xsl:choose>\r\n            </xsl:with-param>\r\n            <xsl:with-param name="ndCur" select="." />\r\n          </xsl:call-template>\r\n          <xsl:element name="m:t">\r\n            <xsl:call-template name="OutputText">\r\n              <xsl:with-param name="sInput" select="$str"/>\r\n            </xsl:call-template>\r\n          </xsl:element>\r\n        </xsl:element>\r\n      </xsl:if>\r\n    </xsl:for-each>\r\n\r\n    <!-- Output MS Right Quote (if need be) -->\r\n    <xsl:if test="self::mml:ms">\r\n      <xsl:variable name="chRquote">\r\n        <xsl:call-template name="RQuoteFromMs">\r\n          <xsl:with-param name="curMs" select="." />\r\n        </xsl:call-template>\r\n      </xsl:variable>\r\n      <xsl:element name="m:r">\r\n        <xsl:call-template name="CreateRunProp">\r\n          <xsl:with-param name="mathvariant" select="$mathvariant" />\r\n          <xsl:with-param name="fontstyle" select="$fontstyle" />\r\n          <xsl:with-param name="fontweight" select="$fontweight" />\r\n          <xsl:with-param name="mathcolor" select="$mathcolor" />\r\n          <xsl:with-param name="mathsize" select="$mathsize" />\r\n          <xsl:with-param name="color" select="$color" />\r\n          <xsl:with-param name="fontsize" select="$fontsize" />\r\n          <xsl:with-param name="fNor" select="$fNor" />\r\n          <xsl:with-param name="ndCur" select="." />\r\n        </xsl:call-template>\r\n        <xsl:element name="m:t">\r\n          <xsl:call-template name="OutputText">\r\n            <xsl:with-param name="sInput" select="$chRquote"/>\r\n          </xsl:call-template>\r\n        </xsl:element>\r\n      </xsl:element>\r\n    </xsl:if>\r\n  </xsl:template>\r\n\r\n  <xsl:template name="FStrContainsNonZeroDigit">\r\n    <xsl:param name="s" />\r\n\r\n    <!-- Translate any nonzero digit into a 9 -->\r\n    <xsl:variable name="sNonZeroDigitsToNineDigit" select="translate($s, '12345678', '99999999')" />\r\n    <xsl:choose>\r\n      <!-- Search for 9s -->\r\n      <xsl:when test="contains($sNonZeroDigitsToNineDigit, '9')">1</xsl:when>\r\n      <xsl:otherwise>0</xsl:otherwise>\r\n    </xsl:choose>\r\n  </xsl:template>\r\n\r\n  <xsl:template name="FStrContainsDigits">\r\n    <xsl:param name="s" />\r\n\r\n    <!-- Translate any digit into a 0 -->\r\n    <xsl:variable name="sDigitsToZeroDigit" select="translate($s, '123456789', '000000000')" />\r\n    <xsl:choose>\r\n      <!-- Search for 0s -->\r\n      <xsl:when test="contains($sDigitsToZeroDigit, '0')">1</xsl:when>\r\n      <xsl:otherwise>0</xsl:otherwise>\r\n    </xsl:choose>\r\n  </xsl:template>\r\n\r\n\r\n  <!-- Used to determine if mpadded attribute {width, height, depth } \r\n       indicates to show everything. \r\n       \r\n       Unlike mathml, whose mpadded structure has great flexibility in modifying the \r\n       bounding box's width, height, and depth, Word can only have zero or full width, height, and depth.\r\n       Thus, if the width, height, or depth attributes indicate any kind of nonzero width, height, \r\n       or depth, we'll translate that into a show full width, height, or depth for OMML.  Only if the attribute\r\n       indicates a zero width, height, or depth, will we report back FFull as false.\r\n       \r\n       Example:  s=0%    ->  FFull returns 0.\r\n                 s=2%    ->  FFull returns 1.\r\n                 s=0.1em ->  FFull returns 1.     \r\n       \r\n       -->\r\n  <xsl:template name="FFull">\r\n    <xsl:param name="s" />\r\n\r\n    <xsl:variable name="fStrContainsNonZeroDigit">\r\n      <xsl:call-template name="FStrContainsNonZeroDigit">\r\n        <xsl:with-param name="s" select="$s" />\r\n      </xsl:call-template>\r\n    </xsl:variable>\r\n\r\n    <xsl:variable name="fStrContainsDigits">\r\n      <xsl:call-template name="FStrContainsDigits">\r\n        <xsl:with-param name="s" select="$s" />\r\n      </xsl:call-template>\r\n    </xsl:variable>\r\n\r\n    <xsl:choose>\r\n      <!-- String contained non-zero digit -->\r\n      <xsl:when test="$fStrContainsNonZeroDigit=1">1</xsl:when>\r\n      <!-- String didn't contain a non-zero digit, but it did contain digits.\r\n           This must mean that all digits in the string were 0s. -->\r\n      <xsl:when test="$fStrContainsDigits=1">0</xsl:when>\r\n      <!-- Else, no digits, therefore, return true.\r\n           We return true in the otherwise condition to take account for the possibility\r\n           in MathML to say something like width="height". -->\r\n      <xsl:otherwise>1</xsl:otherwise>\r\n    </xsl:choose>\r\n  </xsl:template>\r\n\r\n\r\n  <!-- Just outputs phant properties, doesn't do any fancy \r\n       thinking of its own, just obeys the defaults of \r\n       phants. -->\r\n  <xsl:template name="CreatePhantPropertiesCore">\r\n    <xsl:param name="fShow" select="1" />\r\n    <xsl:param name="fFullWidth" select="1" />\r\n    <xsl:param name="fFullHeight" select="1" />\r\n    <xsl:param name="fFullDepth" select="1" />\r\n\r\n    <xsl:if test="$fShow=0 \r\n                    or $fFullWidth=0 \r\n                    or $fFullHeight=0\r\n                    or $fFullDepth=0">\r\n      <xsl:element name="m:phantPr">\r\n        <xsl:if test="$fShow=0">\r\n          <xsl:element name="m:show">\r\n            <xsl:attribute name="m:val">off</xsl:attribute>\r\n          </xsl:element>\r\n        </xsl:if>\r\n        <xsl:if test="$fFullWidth=0">\r\n          <xsl:element name="m:zeroWid">\r\n            <xsl:attribute name="m:val">on</xsl:attribute>\r\n          </xsl:element>\r\n        </xsl:if>\r\n        <xsl:if test="$fFullHeight=0">\r\n          <xsl:element name="m:zeroAsc">\r\n            <xsl:attribute name="m:val">on</xsl:attribute>\r\n          </xsl:element>\r\n        </xsl:if>\r\n        <xsl:if test="$fFullDepth=0">\r\n          <xsl:element name="m:zeroDesc">\r\n            <xsl:attribute name="m:val">on</xsl:attribute>\r\n          </xsl:element>\r\n        </xsl:if>\r\n      </xsl:element>\r\n    </xsl:if>\r\n  </xsl:template>\r\n\r\n  <!-- Figures out if we should factor in width, height, and depth attributes.  \r\n  \r\n       If so, then it \r\n       gets these attributes, does some processing to figure out what the attributes indicate, \r\n       then passes these indications to CreatePhantPropertiesCore.  \r\n       \r\n       If we aren't supposed to factor in width, height, or depth, then we'll just output the show\r\n       attribute. -->\r\n  <xsl:template name="CreatePhantProperties">\r\n    <xsl:param name="ndCur" select="." />\r\n    <xsl:param name="fShow" select="1"/>\r\n\r\n    <xsl:choose>\r\n      <!-- In the special case that we have an mphantom with one child which is an mpadded, then we should \r\n           subsume the mpadded attributes into the mphantom attributes.  The test statement below imples the \r\n           'one child which is an mpadded'.  The first part, that the parent of mpadded is an mphantom, is implied\r\n           by being in this template, which is only called when we've encountered an mphantom.\r\n           \r\n           Word outputs its invisible phantoms with smashing as \r\n\r\n              <mml:mphantom>\r\n                <mml:mpadded . . . >\r\n                  \r\n                </mml:mpadded>\r\n              </mml:mphantom>\r\n\r\n            This test is used to allow roundtripping smashed invisible phantoms. -->\r\n      <xsl:when test="count($ndCur/child::*)=1 and count($ndCur/mml:mpadded)=1">\r\n        <xsl:variable name="sLowerCaseWidth">\r\n          <xsl:choose>\r\n            <xsl:when test="$ndCur/mml:mpadded/@width">\r\n              <xsl:value-of select="translate($ndCur/mml:mpadded/@width, $StrUCAlphabet, $StrLCAlphabet)"/>\r\n            </xsl:when>\r\n            <xsl:otherwise>\r\n              <xsl:value-of select="translate($ndCur/mml:mpadded/@mml:width, $StrUCAlphabet, $StrLCAlphabet)"/>\r\n            </xsl:otherwise>\r\n          </xsl:choose>\r\n        </xsl:variable>\r\n        <xsl:variable name="sLowerCaseHeight">\r\n          <xsl:choose>\r\n            <xsl:when test="$ndCur/mml:mpadded/@height">\r\n              <xsl:value-of select="translate($ndCur/mml:mpadded/@height, $StrUCAlphabet, $StrLCAlphabet)"/>\r\n            </xsl:when>\r\n            <xsl:otherwise>\r\n              <xsl:value-of select="translate($ndCur/mml:mpadded/@mml:height, $StrUCAlphabet, $StrLCAlphabet)"/>\r\n            </xsl:otherwise>\r\n          </xsl:choose>\r\n        </xsl:variable>\r\n        <xsl:variable name="sLowerCaseDepth">\r\n          <xsl:choose>\r\n            <xsl:when test="$ndCur/mml:mpadded/@depth">\r\n              <xsl:value-of select="translate($ndCur/mml:mpadded/@depth, $StrUCAlphabet, $StrLCAlphabet)"/>\r\n            </xsl:when>\r\n            <xsl:otherwise>\r\n              <xsl:value-of select="translate($ndCur/mml:mpadded/@mml:depth, $StrUCAlphabet, $StrLCAlphabet)"/>\r\n            </xsl:otherwise>\r\n          </xsl:choose>\r\n        </xsl:variable>\r\n\r\n        <xsl:variable name="fFullWidth">\r\n          <xsl:call-template name="FFull">\r\n            <xsl:with-param name="s" select="$sLowerCaseWidth" />\r\n          </xsl:call-template>\r\n        </xsl:variable>\r\n        <xsl:variable name="fFullHeight">\r\n          <xsl:call-template name="FFull">\r\n            <xsl:with-param name="s" select="$sLowerCaseHeight" />\r\n          </xsl:call-template>\r\n        </xsl:variable>\r\n        <xsl:variable name="fFullDepth">\r\n          <xsl:call-template name="FFull">\r\n            <xsl:with-param name="s" select="$sLowerCaseDepth" />\r\n          </xsl:call-template>\r\n        </xsl:variable>\r\n\r\n        <xsl:call-template name="CreatePhantPropertiesCore">\r\n          <xsl:with-param name="fShow" select="$fShow"/>\r\n          <xsl:with-param name="fFullWidth" select="$fFullWidth" />\r\n          <xsl:with-param name="fFullHeight" select="$fFullHeight" />\r\n          <xsl:with-param name="fFullDepth" select="$fFullDepth" />\r\n        </xsl:call-template>\r\n      </xsl:when>\r\n      <xsl:otherwise>\r\n        <xsl:call-template name="CreatePhantPropertiesCore">\r\n          <xsl:with-param name="fShow" select="$fShow"/>\r\n        </xsl:call-template>\r\n      </xsl:otherwise>\r\n    </xsl:choose>\r\n  </xsl:template>\r\n\r\n  <xsl:template match="mml:mpadded">\r\n    <xsl:choose>\r\n      <xsl:when test="count(parent::mml:mphantom)=1 and count(preceding-sibling::*)=0 and count(following-sibling::*)=0">\r\n        <!-- This mpadded is inside an mphantom that has already setup phantom attributes, therefore, just apply templates -->\r\n        <xsl:apply-templates select="*" />\r\n      </xsl:when>\r\n      <xsl:otherwise>\r\n        <xsl:variable name="sLowerCaseWidth">\r\n          <xsl:choose>\r\n            <xsl:when test="@width">\r\n              <xsl:value-of select="@width"/>\r\n            </xsl:when>\r\n            <xsl:otherwise>\r\n              <xsl:value-of select="@mml:width"/>\r\n            </xsl:otherwise>\r\n          </xsl:choose>\r\n        </xsl:variable>\r\n        <xsl:variable name="sLowerCaseHeight">\r\n          <xsl:choose>\r\n            <xsl:when test="@height">\r\n              <xsl:value-of select="@height"/>\r\n            </xsl:when>\r\n            <xsl:otherwise>\r\n              <xsl:value-of select="@mml:height"/>\r\n            </xsl:otherwise>\r\n          </xsl:choose>\r\n        </xsl:variable>\r\n        <xsl:variable name="sLowerCaseDepth">\r\n          <xsl:choose>\r\n            <xsl:when test="@depth">\r\n              <xsl:value-of select="@depth"/>\r\n            </xsl:when>\r\n            <xsl:otherwise>\r\n              <xsl:value-of select="@mml:depth"/>\r\n            </xsl:otherwise>\r\n          </xsl:choose>\r\n        </xsl:variable>\r\n\r\n        <xsl:variable name="fFullWidth">\r\n          <xsl:call-template name="FFull">\r\n            <xsl:with-param name="s" select="$sLowerCaseWidth" />\r\n          </xsl:call-template>\r\n        </xsl:variable>\r\n        <xsl:variable name="fFullHeight">\r\n          <xsl:call-template name="FFull">\r\n            <xsl:with-param name="s" select="$sLowerCaseHeight" />\r\n          </xsl:call-template>\r\n        </xsl:variable>\r\n        <xsl:variable name="fFullDepth">\r\n          <xsl:call-template name="FFull">\r\n            <xsl:with-param name="s" select="$sLowerCaseDepth" />\r\n          </xsl:call-template>\r\n        </xsl:variable>\r\n\r\n        <xsl:element name="m:phant">\r\n          <xsl:call-template name="CreatePhantPropertiesCore">\r\n            <xsl:with-param name="fShow" select="1"/>\r\n            <xsl:with-param name="fFullWidth" select="$fFullWidth" />\r\n            <xsl:with-param name="fFullHeight" select="$fFullHeight" />\r\n            <xsl:with-param name="fFullDepth" select="$fFullDepth" />\r\n          </xsl:call-template>\r\n          <m:e>\r\n            <xsl:apply-templates select="*" />\r\n          </m:e>\r\n        </xsl:element>\r\n      </xsl:otherwise>\r\n    </xsl:choose>\r\n  </xsl:template>\r\n\r\n  <xsl:template match="mml:mphantom">\r\n    <xsl:element name="m:phant">\r\n      <xsl:call-template name="CreatePhantProperties">\r\n        <xsl:with-param name="ndCur" select="." />\r\n        <xsl:with-param name="fShow" select="0" />\r\n      </xsl:call-template>\r\n      <m:e>\r\n        <xsl:apply-templates select="*" />\r\n      </m:e>\r\n    </xsl:element>\r\n  </xsl:template>\r\n\r\n  <xsl:template name="isNaryOper">\r\n    <xsl:param name="sNdCur" />\r\n    <xsl:value-of select="($sNdCur = '&#x222B;' \r\n                            or $sNdCur = '&#x222C;' \r\n                            or $sNdCur = '&#x222D;' \r\n                            or $sNdCur = '&#x222E;' \r\n                            or $sNdCur = '&#x222F;' \r\n                            or $sNdCur = '&#x2230;' \r\n                            or $sNdCur = '&#x2232;' \r\n                            or $sNdCur = '&#x2233;' \r\n                            or $sNdCur = '&#x2231;' \r\n                            or $sNdCur = '&#x2229;' \r\n                            or $sNdCur = '&#x222A;' \r\n                            or $sNdCur = '&#x220F;' \r\n                            or $sNdCur = '&#x2210;' \r\n                            or $sNdCur = '&#x2211;' \r\n                            or $sNdCur = '&#x22C0;' \r\n                            or $sNdCur = '&#x22C1;' \r\n                            or $sNdCur = '&#x22C2;' \r\n                            or $sNdCur = '&#x22C3;')" />\r\n  </xsl:template>\r\n\r\n\r\n  <xsl:template name="isNary">\r\n    <!-- ndCur is the element around the nAry operator -->\r\n    <xsl:param name="ndCur" />\r\n    <xsl:variable name="sNdCur">\r\n      <xsl:value-of select="normalize-space($ndCur)" />\r\n    </xsl:variable>\r\n\r\n    <xsl:variable name="fNaryOper">\r\n      <xsl:call-template name="isNaryOper">\r\n        <xsl:with-param name="sNdCur" select="$sNdCur" />\r\n      </xsl:call-template>\r\n    </xsl:variable>\r\n\r\n    <!-- Narys shouldn't be MathML accents.  -->\r\n    <xsl:variable name="fUnder">\r\n      <xsl:choose>\r\n        <xsl:when test="$ndCur/parent::*[self::mml:munder]">1</xsl:when>\r\n        <xsl:otherwise>0</xsl:otherwise>\r\n      </xsl:choose>\r\n    </xsl:variable>\r\n\r\n    <xsl:variable name="sLowerCaseAccent">\r\n      <xsl:choose>\r\n        <xsl:when test="$fUnder=1">\r\n          <xsl:choose>\r\n            <xsl:when test="$ndCur/parent::*[self::mml:munder]/@accentunder">\r\n              <xsl:value-of select="translate($ndCur/parent::*[self::mml:munder]/@accentunder, $StrUCAlphabet, $StrLCAlphabet)"/>\r\n            </xsl:when>\r\n            <xsl:otherwise>\r\n              <xsl:value-of select="translate($ndCur/parent::*[self::mml:munder]/@mml:accentunder, $StrUCAlphabet, $StrLCAlphabet)"/>\r\n            </xsl:otherwise>\r\n          </xsl:choose>\r\n        </xsl:when>\r\n        <xsl:otherwise>\r\n          <xsl:choose>\r\n            <xsl:when test="$ndCur/parent::*/@accent">\r\n              <xsl:value-of select="translate($ndCur/parent::*/@accent, $StrUCAlphabet, $StrLCAlphabet)"/>\r\n            </xsl:when>\r\n            <xsl:otherwise>\r\n              <xsl:value-of select="translate($ndCur/parent::*/@mml:accent, $StrUCAlphabet, $StrLCAlphabet)"/>\r\n            </xsl:otherwise>\r\n          </xsl:choose>\r\n        </xsl:otherwise>\r\n      </xsl:choose>\r\n    </xsl:variable>\r\n\r\n    <xsl:variable name="fAccent">\r\n      <xsl:choose>\r\n        <xsl:when test="$sLowerCaseAccent='true'">1</xsl:when>\r\n        <xsl:otherwise>0</xsl:otherwise>\r\n      </xsl:choose>\r\n    </xsl:variable>\r\n\r\n    <xsl:choose>\r\n      <!-- This ndCur is in fact part of an nAry if\r\n      \r\n           1)  The last descendant of ndCur (which could be ndCur itself) is an operator.\r\n           2)  Along that chain of descendants we only encounter mml:mo, mml:mstyle, and mml:mrow elements.\r\n           3)  the operator in mml:mo is a valid nAry operator\r\n           4)  The nAry is not accented.\r\n           -->\r\n      <xsl:when test="$fNaryOper = 'true'\r\n                      and $fAccent=0\r\n                      and $ndCur/descendant-or-self::*[last()]/self::mml:mo\r\n                      and not($ndCur/descendant-or-self::*[not(self::mml:mo or \r\n\t\t\t                                                     self::mml:mstyle or \r\n\t\t\t                                                     self::mml:mrow)])">\r\n        <xsl:value-of select="true()" />\r\n      </xsl:when>\r\n      <xsl:otherwise>\r\n        <xsl:value-of select="false()" />\r\n      </xsl:otherwise>\r\n    </xsl:choose>\r\n  </xsl:template>\r\n\r\n  <xsl:template name="CreateNaryProp">\r\n    <xsl:param name="chr" />\r\n    <xsl:param name="sMathmlType" />\r\n    <xsl:param name="sGrow">\r\n      <xsl:choose>\r\n        <xsl:when test="child::*[1]/@stretchy">\r\n          <xsl:value-of select="translate(child::*[1]/@stretchy, $StrUCAlphabet, $StrLCAlphabet)"/>\r\n        </xsl:when>\r\n        <xsl:otherwise>\r\n          <xsl:value-of select="translate(child::*[1]/@mml:stretchy, $StrUCAlphabet, $StrLCAlphabet)"/>\r\n        </xsl:otherwise>\r\n      </xsl:choose>\r\n    </xsl:param>\r\n    <m:naryPr>\r\n      <m:chr>\r\n        <xsl:attribute name="m:val">\r\n          <xsl:value-of select="$chr" />\r\n        </xsl:attribute>\r\n      </m:chr>\r\n      <m:limLoc>\r\n        <xsl:attribute name="m:val">\r\n          <xsl:choose>\r\n            <xsl:when test="$sMathmlType='munder' or \r\n\t\t\t\t\t\t\t\t\t$sMathmlType='mover' or \r\n\t\t\t\t\t\t\t\t\t$sMathmlType='munderover'">\r\n              <xsl:text>undOvr</xsl:text>\r\n            </xsl:when>\r\n            <xsl:when test="$sMathmlType='msub' or\r\n\t\t\t\t\t                $sMathmlType='msup' or\r\n\t\t\t\t\t                $sMathmlType='msubsup'">\r\n              <xsl:text>subSup</xsl:text>\r\n            </xsl:when>\r\n          </xsl:choose>\r\n        </xsl:attribute>\r\n      </m:limLoc>\r\n      <m:grow>\r\n        <xsl:attribute name="m:val">\r\n          <xsl:choose>\r\n            <xsl:when test="$sGrow='true'">1</xsl:when>\r\n            <xsl:when test="$sGrow='false'">0</xsl:when>\r\n            <xsl:when test="$chr='&#x222B;' \r\n                            or $chr='&#x222E;' \r\n                            or $chr='&#x222F;' \r\n                            or $chr='&#x2232;' \r\n                            or $chr='&#x2233;'\r\n                            or $chr='&#x2229;'\r\n                            or $chr='&#x222A;' \r\n                            or $chr='&#x220F;' \r\n                            or $chr='&#x2211;' \r\n                            or $chr='&#x22C0;'\r\n                            or $chr='&#x22C1;' \r\n                            or $chr='&#x22C2;'\r\n                            or $chr='&#x22C3;'">1</xsl:when>\r\n            <xsl:otherwise>0</xsl:otherwise>\r\n          </xsl:choose>\r\n        </xsl:attribute>\r\n      </m:grow>\r\n      <m:subHide>\r\n        <xsl:attribute name="m:val">\r\n          <xsl:choose>\r\n            <xsl:when test="$sMathmlType='mover' or\r\n\t\t\t\t\t\t                $sMathmlType='msup'">\r\n              <xsl:text>on</xsl:text>\r\n            </xsl:when>\r\n            <xsl:otherwise>\r\n              <xsl:text>off</xsl:text>\r\n            </xsl:otherwise>\r\n          </xsl:choose>\r\n        </xsl:attribute>\r\n      </m:subHide>\r\n      <m:supHide>\r\n        <xsl:attribute name="m:val">\r\n          <xsl:choose>\r\n            <xsl:when test="$sMathmlType='munder' or\r\n\t\t\t\t\t\t                $sMathmlType='msub'">\r\n              <xsl:text>on</xsl:text>\r\n            </xsl:when>\r\n            <xsl:otherwise>\r\n              <xsl:text>off</xsl:text>\r\n            </xsl:otherwise>\r\n          </xsl:choose>\r\n        </xsl:attribute>\r\n      </m:supHide>\r\n    </m:naryPr>\r\n  </xsl:template>\r\n</xsl:stylesheet>`;

export function getEmbeddedXSLContent(): string {
  return EMBEDDED_XSL_CONTENT;
}
